<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Maps and Pointers - Go Universe</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to Go programming language from basics to advanced topics">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go Universe</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe/edit/main/src/chapters/Chapter-9-Maps-And-Pointers.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-9-maps-and-pointers-in-go"><a class="header" href="#chapter-9-maps-and-pointers-in-go"><strong>Chapter 9: Maps and Pointers in Go</strong></a></h1>
<p>Go's approach to data management balances simplicity, performance, and safety. In this chapter, we'll explore two powerful components of Go's type system: maps and pointers. These features enable efficient data organization and memory manipulation while maintaining Go's commitment to memory safety and clean syntax.</p>
<p>By understanding how maps and pointers work together, you'll be equipped to create efficient data structures that can handle complex real-world problems with elegance and performance.</p>
<h2 id="91-maps-in-go"><a class="header" href="#91-maps-in-go"><strong>9.1 Maps in Go</strong></a></h2>
<h3 id="911-map-fundamentals"><a class="header" href="#911-map-fundamentals"><strong>9.1.1 Map Fundamentals</strong></a></h3>
<p>A map is an unordered collection of key-value pairs where each key is unique. Maps provide fast lookups, insertions, and deletions based on keys. In Go, maps are implemented as hash tables, offering average constant-time complexity for these operations.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Method 1: Using make
    scores := make(map[string]int)

    // Method 2: Map literal (empty)
    ages := map[string]int{}

    // Method 3: Map literal with initial data
    population := map[string]int{
        "New York": 8804190,
        "Los Angeles": 3898747,
        "Chicago": 2746388,
    }

    fmt.Println("Scores:", scores)           // map[]
    fmt.Println("Ages:", ages)               // map[]
    fmt.Println("Population:", population)   // map[Chicago:2746388 Los Angeles:3898747 New York:8804190]
}
</code></pre>
<p>Key characteristics of Go maps:</p>
<ul>
<li><strong>Unordered</strong>: Unlike arrays and slices, maps don't maintain insertion order</li>
<li><strong>Dynamic</strong>: Maps grow automatically as you add more key-value pairs</li>
<li><strong>Reference Type</strong>: Maps are passed by reference, not by value</li>
<li><strong>Type Requirements</strong>: Keys must be comparable (support the <code>==</code> and <code>!=</code> operators)</li>
<li><strong>Zero Value</strong>: The zero value of a map is <code>nil</code></li>
</ul>
<p>A <code>nil</code> map cannot store key-value pairs:</p>
<pre><code class="language-go">var nilMap map[string]int        // Nil map
// nilMap["key"] = 10            // Runtime panic: assignment to entry in nil map
</code></pre>
<h3 id="912-working-with-maps"><a class="header" href="#912-working-with-maps"><strong>9.1.2 Working with Maps</strong></a></h3>
<p>Let's explore the fundamental operations you can perform with maps:</p>
<p><strong>Adding and Updating Elements</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    users := make(map[int]string)

    // Adding new key-value pairs
    users[1] = "Alice"
    users[2] = "Bob"

    fmt.Println("Users:", users)  // map[1:Alice 2:Bob]

    // Updating an existing value
    users[1] = "Alicia"
    fmt.Println("Updated users:", users)  // map[1:Alicia 2:Bob]
}
</code></pre>
<p><strong>Retrieving Values and Checking Existence</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    colors := map[string]string{
        "red": "#FF0000",
        "green": "#00FF00",
        "blue": "#0000FF",
    }

    // Simple retrieval
    redHex := colors["red"]
    fmt.Println("Red hex code:", redHex)  // #FF0000

    // The "comma ok" idiom for checking existence
    yellowHex, exists := colors["yellow"]
    if exists {
        fmt.Println("Yellow hex code:", yellowHex)
    } else {
        fmt.Println("Yellow color not found")  // This will print
    }
}
</code></pre>
<p><strong>Deleting Key-Value Pairs</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    inventory := map[string]int{
        "apple": 15,
        "banana": 8,
        "orange": 12,
    }

    fmt.Println("Initial inventory:", inventory)

    // Delete a key-value pair
    delete(inventory, "banana")
    fmt.Println("After deletion:", inventory)

    // Deleting a non-existent key is a no-op (doesn't cause errors)
    delete(inventory, "grape")
    fmt.Println("After deleting non-existent key:", inventory)
}
</code></pre>
<p><strong>Iterating Over Maps</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    capitals := map[string]string{
        "France": "Paris",
        "Japan": "Tokyo",
        "India": "New Delhi",
        "Brazil": "Brasília",
    }

    // Iterating over keys and values
    fmt.Println("Countries and their capitals:")
    for country, capital := range capitals {
        fmt.Printf("%s: %s\n", country, capital)
    }

    // Iterating over just the keys
    fmt.Println("\nList of countries:")
    for country := range capitals {
        fmt.Println(country)
    }
}
</code></pre>
<p>Note: The iteration order of a map is not guaranteed. Each iteration might produce a different order of keys and values. If you need a specific order, you should sort the keys separately.</p>
<h3 id="913-maps-with-complex-types"><a class="header" href="#913-maps-with-complex-types"><strong>9.1.3 Maps with Complex Types</strong></a></h3>
<p>Maps can have complex types for both keys and values:</p>
<p><strong>Structs as Map Values</strong></p>
<pre><code class="language-go">package main

import "fmt"

type Employee struct {
    Name   string
    Title  string
    Salary float64
}

func main() {
    employees := map[string]Employee{
        "E001": {Name: "Alice Johnson", Title: "Software Engineer", Salary: 85000},
        "E002": {Name: "Bob Smith", Title: "Product Manager", Salary: 95000},
    }

    // Accessing a struct field in a map value
    fmt.Printf("%s is a %s\n", employees["E001"].Name, employees["E001"].Title)

    // Updating a struct field
    employee := employees["E002"]
    employee.Salary += 5000
    employees["E002"] = employee  // Map values are not addressable directly

    fmt.Printf("%s's new salary: $%.2f\n", employees["E002"].Name, employees["E002"].Salary)
}
</code></pre>
<p><strong>Maps as Values in Other Maps (Nested Maps)</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Nested map for a university course catalog
    courseCatalog := map[string]map[string]string{
        "CS": {
            "CS101": "Introduction to Programming",
            "CS202": "Data Structures",
            "CS303": "Algorithms",
        },
        "MATH": {
            "MATH101": "Calculus I",
            "MATH202": "Linear Algebra",
        },
    }

    // Accessing values in nested maps
    fmt.Println("CS202:", courseCatalog["CS"]["CS202"])

    // Adding a new department
    courseCatalog["PHYS"] = map[string]string{
        "PHYS101": "Physics I",
    }

    // Adding a new course to an existing department
    courseCatalog["MATH"]["MATH303"] = "Differential Equations"

    // Printing the entire catalog
    for dept, courses := range courseCatalog {
        fmt.Printf("\nDepartment: %s\n", dept)
        for code, title := range courses {
            fmt.Printf("  %s: %s\n", code, title)
        }
    }
}
</code></pre>
<p><strong>Slices as Map Values</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Map with slices as values
    studentScores := map[string][]int{
        "Alice": {92, 87, 95},
        "Bob":   {85, 79, 91},
    }

    // Adding a new student
    studentScores["Charlie"] = []int{88, 92}

    // Adding a score to an existing student
    studentScores["Alice"] = append(studentScores["Alice"], 90)

    // Calculating averages
    fmt.Println("Average scores:")
    for student, scores := range studentScores {
        sum := 0
        for _, score := range scores {
            sum += score
        }
        avg := float64(sum) / float64(len(scores))
        fmt.Printf("%s: %.2f\n", student, avg)
    }
}
</code></pre>
<h3 id="914-maps-in-concurrent-environments"><a class="header" href="#914-maps-in-concurrent-environments"><strong>9.1.4 Maps in Concurrent Environments</strong></a></h3>
<p>Maps in Go are not safe for concurrent use. If multiple goroutines access a map simultaneously and at least one of them is writing, you must implement synchronization:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func main() {
    // A thread-safe map using a mutex
    type ConcurrentMap struct {
        mu   sync.RWMutex
        data map[string]int
    }

    counter := ConcurrentMap{
        data: make(map[string]int),
    }

    // Thread-safe methods
    increment := func(key string) {
        counter.mu.Lock()
        defer counter.mu.Unlock()
        counter.data[key]++
    }

    getValue := func(key string) int {
        counter.mu.RLock()
        defer counter.mu.RUnlock()
        return counter.data[key]
    }

    // Increment a counter
    increment("visits")
    increment("visits")
    increment("logins")

    fmt.Println("Visits:", getValue("visits"))
    fmt.Println("Logins:", getValue("logins"))
}
</code></pre>
<p>For Go 1.9 and later, you can also use the <code>sync.Map</code> type, which is optimized for specific use cases:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func main() {
    var counter sync.Map

    // Store values
    counter.Store("visits", 0)

    // Increment a counter
    increment := func(key string) {
        var count int
        value, ok := counter.Load(key)
        if ok {
            count = value.(int)
        }
        counter.Store(key, count+1)
    }

    // Increment the counter
    increment("visits")
    increment("visits")
    increment("logins")

    // Retrieve values
    visits, _ := counter.Load("visits")
    logins, _ := counter.Load("logins")

    fmt.Println("Visits:", visits)
    fmt.Println("Logins:", logins)
}
</code></pre>
<h3 id="915-practical-map-applications"><a class="header" href="#915-practical-map-applications"><strong>9.1.5 Practical Map Applications</strong></a></h3>
<p><strong>Word Frequency Counter</strong></p>
<p>Maps are perfect for counting occurrences of items:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "strings"
)

func wordFrequency(text string) map[string]int {
    // Convert to lowercase and split into words
    words := strings.Fields(strings.ToLower(text))

    // Create a map to store word counts
    frequency := make(map[string]int)

    // Count word occurrences
    for _, word := range words {
        // Remove punctuation (simplified approach)
        word = strings.Trim(word, ".,!?;:()")
        if word != "" {
            frequency[word]++
        }
    }

    return frequency
}

func main() {
    text := "Go is an open source programming language. Go is expressive, concise, clean, and efficient."

    freq := wordFrequency(text)

    // Print results
    fmt.Println("Word frequencies:")
    for word, count := range freq {
        fmt.Printf("%-12s: %d\n", word, count)
    }
}
</code></pre>
<p><strong>Implementing a Cache</strong></p>
<p>Maps can implement simple cache mechanisms:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

// Expensive calculation function
func fibonacci(n int, cache map[int]int) int {
    // Check if result is already cached
    if val, found := cache[n]; found {
        fmt.Printf("Cache hit for fib(%d)\n", n)
        return val
    }

    fmt.Printf("Computing fib(%d)\n", n)
    var result int

    // Base cases
    if n &lt;= 1 {
        result = n
    } else {
        // Recursive calculation
        result = fibonacci(n-1, cache) + fibonacci(n-2, cache)
    }

    // Store result in cache
    cache[n] = result
    return result
}

func main() {
    cache := make(map[int]int)

    start := time.Now()
    result := fibonacci(40, cache)
    duration := time.Since(start)

    fmt.Printf("fibonacci(40) = %d\n", result)
    fmt.Printf("Calculation took %v\n", duration)
    fmt.Printf("Cache size: %d entries\n", len(cache))
}
</code></pre>
<h2 id="92-understanding-memory-in-go"><a class="header" href="#92-understanding-memory-in-go"><strong>9.2 Understanding Memory in Go</strong></a></h2>
<h3 id="921-value-types-vs-reference-types"><a class="header" href="#921-value-types-vs-reference-types"><strong>9.2.1 Value Types vs. Reference Types</strong></a></h3>
<p>Go has two fundamental categories of types:</p>
<p><strong>Value Types</strong>:</p>
<ul>
<li>Basic types (int, float, bool, string)</li>
<li>Arrays</li>
<li>Structs</li>
</ul>
<p><strong>Reference Types</strong>:</p>
<ul>
<li>Slices</li>
<li>Maps</li>
<li>Channels</li>
<li>Functions</li>
<li>Pointers</li>
</ul>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Value type: Assignment creates a copy
    x := 5
    y := x
    x = 10
    fmt.Println("x:", x, "y:", y) // x: 10 y: 5

    // Reference type: Assignment creates a reference
    slice1 := []int{1, 2, 3}
    slice2 := slice1
    slice1[0] = 99
    fmt.Println("slice1:", slice1, "slice2:", slice2) // Both contain [99 2 3]

    // Maps are reference types
    map1 := map[string]int{"a": 1}
    map2 := map1
    map1["a"] = 100
    fmt.Println("map1:", map1, "map2:", map2) // Both contain map[a:100]
}
</code></pre>
<h3 id="922-memory-allocation-in-go"><a class="header" href="#922-memory-allocation-in-go"><strong>9.2.2 Memory Allocation in Go</strong></a></h3>
<p>Go has two primary places where memory can be allocated:</p>
<ul>
<li><strong>Stack</strong>: Fast, automatically managed, limited size</li>
<li><strong>Heap</strong>: Slower, garbage-collected, virtually unlimited size</li>
</ul>
<pre><code class="language-go">package main

import "fmt"

// This function likely uses only stack allocation
func stackAllocation() int {
    x := 10      // Local variable - stack allocated
    y := 20      // Local variable - stack allocated
    return x + y // Result returned by value - no heap needed
}

// This function likely causes heap allocation
func heapAllocation() *int {
    x := 10     // Initially stack allocated
    return &amp;x   // But now escapes to the heap because we return its address
}

func main() {
    result1 := stackAllocation()
    result2 := heapAllocation()

    fmt.Println("Stack result:", result1)
    fmt.Println("Heap result:", *result2)
}
</code></pre>
<h3 id="923-escape-analysis"><a class="header" href="#923-escape-analysis"><strong>9.2.3 Escape Analysis</strong></a></h3>
<p>Go's compiler performs escape analysis to determine which allocations need to be on the heap:</p>
<pre><code class="language-go">package main

import "fmt"

type MyStruct struct {
    value int
}

// This likely stays on the stack
func createOnStack() MyStruct {
    s := MyStruct{value: 42}
    return s // Return by value, copy is made
}

// This must escape to the heap
func createOnHeap() *MyStruct {
    s := MyStruct{value: 42}
    return &amp;s // Return address, must escape
}

func main() {
    s1 := createOnStack()
    s2 := createOnHeap()

    fmt.Println("Stack allocated:", s1.value)
    fmt.Println("Heap allocated:", s2.value)

    // You can use the -gcflags=-m flag to see escape analysis:
    // go build -gcflags=-m main.go
}
</code></pre>
<h2 id="93-pointers-in-go"><a class="header" href="#93-pointers-in-go"><strong>9.3 Pointers in Go</strong></a></h2>
<h3 id="931-pointer-fundamentals"><a class="header" href="#931-pointer-fundamentals"><strong>9.3.1 Pointer Fundamentals</strong></a></h3>
<p>A pointer is a variable that stores the memory address of another variable. Instead of containing the actual value, it "points to" where the value is stored in memory.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Declare a regular variable
    value := 42

    // Declare a pointer to that variable
    var ptr *int = &amp;value

    fmt.Println("Value:", value)           // 42
    fmt.Println("Address of value:", &amp;value) // e.g., 0xc0000180a8
    fmt.Println("Pointer:", ptr)            // e.g., 0xc0000180a8
    fmt.Println("Value at pointer:", *ptr)  // 42
}
</code></pre>
<p>Key pointer operators in Go:</p>
<ul>
<li><code>&amp;</code> (address-of operator): Gets the memory address of a variable</li>
<li><code>*</code> (dereference operator): Accesses the value stored at a memory address</li>
<li><code>*Type</code> (pointer type): Declares a pointer to a specific type</li>
</ul>
<h3 id="932-pointer-zero-value"><a class="header" href="#932-pointer-zero-value"><strong>9.3.2 Pointer Zero Value</strong></a></h3>
<p>The zero value of a pointer is <code>nil</code>, which represents a pointer that doesn't point to anything.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    var ptr *int // Declare a pointer without initialization

    fmt.Println("Pointer value:", ptr) // nil

    // This would cause a panic:
    // fmt.Println("Value at pointer:", *ptr)

    // Safe way to work with pointers
    if ptr != nil {
        fmt.Println("Value at pointer:", *ptr)
    } else {
        fmt.Println("Pointer is nil")
    }
}
</code></pre>
<p>Always check if a pointer is <code>nil</code> before dereferencing it to avoid runtime panics.</p>
<h3 id="933-creating-and-using-pointers"><a class="header" href="#933-creating-and-using-pointers"><strong>9.3.3 Creating and Using Pointers</strong></a></h3>
<p>There are several ways to create pointers in Go:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Method 1: Using the address-of operator
    x := 10
    ptr1 := &amp;x

    // Method 2: Using new() function
    ptr2 := new(int) // Creates a pointer to a zero-initialized int
    *ptr2 = 20

    // Method 3: From another pointer
    ptr3 := ptr1

    fmt.Println("ptr1 points to:", *ptr1) // 10
    fmt.Println("ptr2 points to:", *ptr2) // 20
    fmt.Println("ptr3 points to:", *ptr3) // 10

    // Modifying through pointers
    *ptr1 = 15
    fmt.Println("After modification:")
    fmt.Println("x =", x)          // 15
    fmt.Println("*ptr1 =", *ptr1)  // 15
    fmt.Println("*ptr3 =", *ptr3)  // 15
}
</code></pre>
<h3 id="934-pass-by-value-vs-pass-by-reference"><a class="header" href="#934-pass-by-value-vs-pass-by-reference"><strong>9.3.4 Pass By Value vs. Pass By Reference</strong></a></h3>
<p>Go is strictly pass-by-value, but pointers allow you to simulate pass-by-reference behavior:</p>
<pre><code class="language-go">package main

import "fmt"

// Pass by value - cannot modify the original
func doubleValue(n int) {
    n *= 2
    fmt.Println("Inside doubleValue:", n)
}

// Pass by reference using pointers - can modify the original
func doubleValueByPointer(n *int) {
    *n *= 2
    fmt.Println("Inside doubleValueByPointer:", *n)
}

func main() {
    num := 10

    // Pass by value
    fmt.Println("Before doubleValue:", num)
    doubleValue(num)
    fmt.Println("After doubleValue:", num) // Still 10

    // Pass by reference
    fmt.Println("\nBefore doubleValueByPointer:", num)
    doubleValueByPointer(&amp;num)
    fmt.Println("After doubleValueByPointer:", num) // Now 20
}
</code></pre>
<p>When to use each approach:</p>
<div class="table-wrapper"><table><thead><tr><th>Pass by Value</th><th>Pass by Reference (using pointers)</th></tr></thead><tbody>
<tr><td>For small data types (int, bool, etc.)</td><td>For large structs (to avoid copying)</td></tr>
<tr><td>When you don't need to modify the original</td><td>When you need to modify the original</td></tr>
<tr><td>When you want to ensure immutability</td><td>When you're working with shared state</td></tr>
</tbody></table>
</div>
<h3 id="935-pointers-to-different-types"><a class="header" href="#935-pointers-to-different-types"><strong>9.3.5 Pointers to Different Types</strong></a></h3>
<p>Pointers can be used with any type in Go:</p>
<p><strong>Pointers to Structs</strong></p>
<pre><code class="language-go">package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func updateAge(p *Person, newAge int) {
    p.Age = newAge
    // Note: Go allows p.Age instead of (*p).Age for convenience
}

func main() {
    alice := Person{Name: "Alice", Age: 30}

    fmt.Printf("Before: %+v\n", alice)

    updateAge(&amp;alice, 31)

    fmt.Printf("After: %+v\n", alice)
}
</code></pre>
<p><strong>Pointers to Arrays</strong></p>
<pre><code class="language-go">package main

import "fmt"

func modifyArray(arr *[3]int) {
    (*arr)[0] = 100
    // Or use the shorthand: arr[0] = 100
}

func main() {
    // Array
    array := [3]int{1, 2, 3}
    fmt.Println("Before modifyArray:", array)
    modifyArray(&amp;array)
    fmt.Println("After modifyArray:", array)
}
</code></pre>
<p><strong>Pointers to Slices</strong></p>
<pre><code class="language-go">package main

import "fmt"

func modifySlice(slice []int) {
    // No pointer needed for modifying slice elements
    slice[0] = 100
}

func appendToSlice(slicePtr *[]int) {
    // Pointer needed to change the slice itself (length/capacity)
    *slicePtr = append(*slicePtr, 4, 5, 6)
}

func main() {
    // Slice - no pointer needed to modify elements
    slice := []int{1, 2, 3}
    fmt.Println("Before modifySlice:", slice)
    modifySlice(slice)
    fmt.Println("After modifySlice:", slice)

    // Slice - pointer needed to change the slice itself
    fmt.Println("Before appendToSlice:", slice)
    appendToSlice(&amp;slice)
    fmt.Println("After appendToSlice:", slice)
}
</code></pre>
<h3 id="936-pointer-receiver-methods"><a class="header" href="#936-pointer-receiver-methods"><strong>9.3.6 Pointer Receiver Methods</strong></a></h3>
<p>Go methods can have either value receivers or pointer receivers:</p>
<pre><code class="language-go">package main

import "fmt"

type Counter struct {
    value int
}

// Value receiver - receives a copy of the Counter
func (c Counter) ValueIncrement() {
    c.value++
    fmt.Println("Inside ValueIncrement:", c.value)
}

// Pointer receiver - receives a pointer to the Counter
func (c *Counter) PointerIncrement() {
    c.value++
    fmt.Println("Inside PointerIncrement:", c.value)
}

func main() {
    counter := Counter{value: 0}

    // Using value receiver
    fmt.Println("Before ValueIncrement:", counter.value)
    counter.ValueIncrement()
    fmt.Println("After ValueIncrement:", counter.value) // Still 0

    // Using pointer receiver
    fmt.Println("\nBefore PointerIncrement:", counter.value)
    counter.PointerIncrement()
    fmt.Println("After PointerIncrement:", counter.value) // Now 1

    // Go automatically handles address-of operation
    counterCopy := counter
    counterCopy.PointerIncrement() // Go converts to (&amp;counterCopy).PointerIncrement()
    fmt.Println("\nAfter PointerIncrement on copy:", counterCopy.value) // 2
    fmt.Println("Original counter:", counter.value) // Still 1
}
</code></pre>
<p>Guidelines for choosing the receiver type:</p>
<ul>
<li>Use pointer receivers when you need to modify the receiver</li>
<li>Use pointer receivers when the receiver is large (for efficiency)</li>
<li>Use value receivers when the receiver is small and immutable</li>
<li>Be consistent: if some methods need pointer receivers, consider using pointer receivers for all methods of that type</li>
</ul>
<h2 id="94-maps-and-pointers-in-practice"><a class="header" href="#94-maps-and-pointers-in-practice"><strong>9.4 Maps and Pointers in Practice</strong></a></h2>
<h3 id="941-combining-maps-and-pointers"><a class="header" href="#941-combining-maps-and-pointers"><strong>9.4.1 Combining Maps and Pointers</strong></a></h3>
<p>Maps and pointers work together in powerful ways:</p>
<pre><code class="language-go">package main

import "fmt"

type User struct {
    Name  string
    Email string
    Age   int
}

func main() {
    // Map of pointers to structs
    userMap := make(map[string]*User)

    // Add users to the map
    userMap["alice"] = &amp;User{Name: "Alice", Email: "alice@example.com", Age: 30}
    userMap["bob"] = &amp;User{Name: "Bob", Email: "bob@example.com", Age: 25}

    // Directly modify a struct through the map
    userMap["alice"].Age = 31

    // Print all users
    for username, userPtr := range userMap {
        fmt.Printf("User %s: %+v\n", username, *userPtr)
    }
}
</code></pre>
<h3 id="942-implementing-a-key-value-store"><a class="header" href="#942-implementing-a-key-value-store"><strong>9.4.2 Implementing a Key-Value Store</strong></a></h3>
<p>Let's implement a simple key-value store with expiration using maps and pointers:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type Item struct {
    Value      interface{}
    Expiration int64
}

type Cache struct {
    mu    sync.RWMutex
    items map[string]*Item
}

func NewCache() *Cache {
    cache := &amp;Cache{
        items: make(map[string]*Item),
    }
    go cache.cleanupRoutine()
    return cache
}

func (c *Cache) Set(key string, value interface{}, duration time.Duration) {
    expiration := time.Now().Add(duration).UnixNano()
    item := &amp;Item{
        Value:      value,
        Expiration: expiration,
    }

    c.mu.Lock()
    c.items[key] = item
    c.mu.Unlock()
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    item, found := c.items[key]
    if !found {
        return nil, false
    }

    // Check if the item has expired
    if item.Expiration &gt; 0 &amp;&amp; item.Expiration &lt; time.Now().UnixNano() {
        return nil, false
    }

    return item.Value, true
}

func (c *Cache) Delete(key string) {
    c.mu.Lock()
    delete(c.items, key)
    c.mu.Unlock()
}

func (c *Cache) cleanupRoutine() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()

    for {
        &lt;-ticker.C
        c.mu.Lock()
        now := time.Now().UnixNano()
        for key, item := range c.items {
            if item.Expiration &gt; 0 &amp;&amp; item.Expiration &lt; now {
                delete(c.items, key)
            }
        }
        c.mu.Unlock()
    }
}

func main() {
    cache := NewCache()

    // Set some values with different expiration times
    cache.Set("key1", "value1", 1*time.Hour)
    cache.Set("key2", 42, 2*time.Second)

    // Retrieve values
    if val, found := cache.Get("key1"); found {
        fmt.Println("key1:", val)
    }

    if val, found := cache.Get("key2"); found {
        fmt.Println("key2:", val)
    }

    // Wait for key2 to expire
    time.Sleep(3 * time.Second)

    // Try to get key2 again
    if val, found := cache.Get("key2"); found {
        fmt.Println("key2:", val)
    } else {
        fmt.Println("key2 has expired")
    }
}
</code></pre>
<h3 id="943-memory-optimization-techniques"><a class="header" href="#943-memory-optimization-techniques"><strong>9.4.3 Memory Optimization Techniques</strong></a></h3>
<p>Here are some techniques for optimizing memory usage with maps and pointers:</p>
<p><strong>Preallocate Maps</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Preallocate map with expected size
    userMap := make(map[string]string, 1000)

    // Fill the map
    for i := 0; i &lt; 1000; i++ {
        key := fmt.Sprintf("user%d", i)
        userMap[key] = fmt.Sprintf("data%d", i)
    }

    fmt.Printf("Map contains %d items\n", len(userMap))
}
</code></pre>
<p><strong>Use Pointers for Large Structs</strong></p>
<pre><code class="language-go">package main

import "fmt"

type LargeStruct struct {
    Data [1024]int
    // Many other fields...
}

func main() {
    // Bad: Map of large structs (lots of copying)
    mapOfStructs := make(map[string]LargeStruct)

    // Good: Map of pointers to structs (minimal copying)
    mapOfPointers := make(map[string]*LargeStruct)

    // Add an item
    mapOfPointers["key"] = &amp;LargeStruct{}

    fmt.Println("Added large struct to map")
}
</code></pre>
<p><strong>Clear Maps Instead of Reallocating</strong></p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Create a map
    dataMap := make(map[string]int)

    // Fill it with data
    for i := 0; i &lt; 100; i++ {
        dataMap[fmt.Sprintf("key%d", i)] = i
    }

    fmt.Printf("Map has %d entries\n", len(dataMap))

    // Clear the map instead of reallocating
    for k := range dataMap {
        delete(dataMap, k)
    }

    fmt.Printf("Map has %d entries after clearing\n", len(dataMap))

    // Reuse the map
    for i := 0; i &lt; 50; i++ {
        dataMap[fmt.Sprintf("newkey%d", i)] = i * 10
    }

    fmt.Printf("Map has %d entries after reuse\n", len(dataMap))
}
</code></pre>
<h2 id="95-summary"><a class="header" href="#95-summary"><strong>9.5 Summary</strong></a></h2>
<p>In this chapter, we've explored two fundamental concepts in Go's type system: maps and pointers. These features enable efficient data organization and memory manipulation while maintaining Go's commitment to memory safety.</p>
<p>Key takeaways:</p>
<ul>
<li><strong>Maps</strong> provide a flexible and efficient way to store key-value pairs, with constant-time lookups and updates.</li>
<li><strong>Pointers</strong> allow direct memory access and manipulation, enabling more efficient memory usage and the ability to modify values across function boundaries.</li>
<li><strong>Memory management</strong> in Go involves both stack and heap allocation, with the compiler's escape analysis determining where values are stored.</li>
<li><strong>Combining maps and pointers</strong> creates powerful data structures that can efficiently handle complex data relationships.</li>
</ul>
<p>By understanding these concepts, you can write more efficient and expressive Go code that makes the best use of memory resources.</p>
<p><strong>Next Up</strong>: In Chapter 10, we'll explore structs and methods, building on your understanding of pointers to implement object-oriented patterns in Go.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/Chapter-8-Arrays-Slices-Strings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/Chapter-10-Structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/Chapter-8-Arrays-Slices-Strings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/Chapter-10-Structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
