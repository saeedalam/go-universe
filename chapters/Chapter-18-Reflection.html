<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reflection - Go Universe</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to Go programming language from basics to advanced topics">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go Universe</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe/edit/main/src/chapters/Chapter-18-Reflection.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-18-reflection-in-go"><a class="header" href="#chapter-18-reflection-in-go"><strong>Chapter 18: Reflection in Go</strong></a></h1>
<p>Reflection is a powerful feature in Go that allows programs to examine and modify their own structure and behavior at runtime. While Go is primarily a statically typed language, reflection provides a way to work with types dynamically. This chapter explores Go's reflection capabilities, their applications, and best practices for using this advanced feature effectively.</p>
<h2 id="181-introduction-to-reflection"><a class="header" href="#181-introduction-to-reflection"><strong>18.1 Introduction to Reflection</strong></a></h2>
<p>Reflection enables a program to inspect and manipulate objects at runtime without knowing their types at compile time. In Go, reflection is implemented through the <code>reflect</code> package in the standard library.</p>
<h3 id="1811-what-is-reflection"><a class="header" href="#1811-what-is-reflection"><strong>18.1.1 What is Reflection?</strong></a></h3>
<p>Reflection provides the ability to:</p>
<ul>
<li>Examine the type of a variable at runtime</li>
<li>Access and modify fields of a struct dynamically</li>
<li>Call methods on objects without knowing their exact type</li>
<li>Create new values of a particular type</li>
<li>Inspect and modify values indirectly</li>
</ul>
<p>In essence, reflection gives us a way to work with code that manipulates other code rather than just performing computation directly.</p>
<h3 id="1812-when-to-use-reflection"><a class="header" href="#1812-when-to-use-reflection"><strong>18.1.2 When to Use Reflection</strong></a></h3>
<p>Reflection is powerful but comes with trade-offs:</p>
<ul>
<li><strong>Performance impact</strong>: Reflection operations are significantly slower than direct code</li>
<li><strong>Type safety</strong>: Many reflection errors only appear at runtime</li>
<li><strong>Code complexity</strong>: Reflection code is often more complex and harder to understand</li>
</ul>
<p>Because of these drawbacks, reflection should be used judiciously. Common use cases include:</p>
<ul>
<li>Generic data handling (JSON/XML serialization)</li>
<li>Implementing flexible APIs that work with arbitrary types</li>
<li>Building testing and mocking frameworks</li>
<li>Creating object-relational mappers (ORMs)</li>
<li>Dynamic configuration and dependency injection</li>
</ul>
<p>The Go proverb "Clear is better than clever" is particularly relevant when considering reflection. Use reflection only when the benefits clearly outweigh the costs.</p>
<h2 id="182-fundamentals-of-reflection"><a class="header" href="#182-fundamentals-of-reflection"><strong>18.2 Fundamentals of Reflection</strong></a></h2>
<p>The <code>reflect</code> package provides two main types that form the foundation of reflection in Go:</p>
<ul>
<li><code>reflect.Type</code>: Represents the type of a Go value</li>
<li><code>reflect.Value</code>: Represents the value itself</li>
</ul>
<p>These types, along with their methods, enable the inspection and manipulation of Go values at runtime.</p>
<h3 id="1821-the-basic-reflection-functions"><a class="header" href="#1821-the-basic-reflection-functions"><strong>18.2.1 The Basic Reflection Functions</strong></a></h3>
<p>The <code>reflect</code> package provides three fundamental functions:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

func main() {
    // Create some variables of different types
    var i int = 42
    var s string = "hello"
    var f float64 = 3.14159

    // Use reflect.TypeOf to get the type
    fmt.Println("Type of i:", reflect.TypeOf(i))   // int
    fmt.Println("Type of s:", reflect.TypeOf(s))   // string
    fmt.Println("Type of f:", reflect.TypeOf(f))   // float64

    // Use reflect.ValueOf to get a Value representing the value
    vi := reflect.ValueOf(i)
    vs := reflect.ValueOf(s)

    // Get the underlying value with Interface()
    fmt.Println("Value of vi:", vi.Interface()) // 42
    fmt.Println("Value of vs:", vs.Interface()) // hello

    // Create a new value with reflect.New
    // This creates a pointer to a new zero value of the specified type
    newIntPtr := reflect.New(reflect.TypeOf(i))
    fmt.Println("Type of newIntPtr:", newIntPtr.Type()) // *int
    fmt.Println("Value of newIntPtr:", newIntPtr.Elem().Interface()) // 0
}
</code></pre>
<p>These functions provide the entry points for reflection:</p>
<ol>
<li><code>reflect.TypeOf(x)</code>: Returns a <code>reflect.Type</code> representing the type of <code>x</code></li>
<li><code>reflect.ValueOf(x)</code>: Returns a <code>reflect.Value</code> representing the value of <code>x</code></li>
<li><code>reflect.New(type)</code>: Creates a new value of the specified type</li>
</ol>
<h3 id="1822-kind-vs-type"><a class="header" href="#1822-kind-vs-type"><strong>18.2.2 Kind vs. Type</strong></a></h3>
<p>In reflection, there's an important distinction between a value's "kind" and its "type":</p>
<ul>
<li><strong>Type</strong>: The specific type of a value, such as <code>string</code>, <code>int</code>, or a user-defined type like <code>Person</code></li>
<li><strong>Kind</strong>: The underlying base type category, such as <code>Int</code>, <code>String</code>, <code>Struct</code>, or <code>Slice</code></li>
</ul>
<p>A custom type and its underlying base type have the same kind but different types:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type MyInt int
type Person struct {
    Name string
    Age  int
}

func main() {
    var i MyInt = 42
    var p Person = Person{"Alice", 30}

    // Type includes the package path and name
    fmt.Println("Type of i:", reflect.TypeOf(i)) // main.MyInt
    fmt.Println("Type of p:", reflect.TypeOf(p)) // main.Person

    // Kind is the underlying base type category
    fmt.Println("Kind of i:", reflect.ValueOf(i).Kind()) // int
    fmt.Println("Kind of p:", reflect.ValueOf(p).Kind()) // struct

    // Regular int and MyInt have different types but same kind
    var regularInt int = 42
    fmt.Println("Types equal?", reflect.TypeOf(i) == reflect.TypeOf(regularInt)) // false
    fmt.Println("Kinds equal?", reflect.ValueOf(i).Kind() == reflect.ValueOf(regularInt).Kind()) // true
}
</code></pre>
<p>Understanding this distinction is crucial when working with reflection. The <code>Kind</code> determines what operations are valid on a given value.</p>
<h2 id="183-working-with-reflecttype"><a class="header" href="#183-working-with-reflecttype"><strong>18.3 Working with reflect.Type</strong></a></h2>
<p>The <code>reflect.Type</code> interface provides methods for examining type information at runtime. This is useful for generic programming, type checking, and documentation generation.</p>
<h3 id="1831-basic-type-information"><a class="header" href="#1831-basic-type-information"><strong>18.3.1 Basic Type Information</strong></a></h3>
<p><code>reflect.Type</code> provides methods to access basic type information:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type User struct {
    ID        int
    Name      string
    Email     string
    IsActive  bool
    CreatedAt string
}

func main() {
    u := User{1, "Alice", "alice@example.com", true, "2023-01-01"}
    t := reflect.TypeOf(u)

    // Basic type information
    fmt.Println("Type name:", t.Name())           // User
    fmt.Println("Package path:", t.PkgPath())     // main
    fmt.Println("Kind:", t.Kind())                // struct
    fmt.Println("Size in bytes:", t.Size())       // varies by architecture
    fmt.Println("Is variable sized?", t.VariableLen()) // false

    // For a slice, it would be different
    s := []int{1, 2, 3}
    sliceType := reflect.TypeOf(s)
    fmt.Println("Slice type name:", sliceType.Name())        // "" (anonymous)
    fmt.Println("Slice kind:", sliceType.Kind())             // slice
    fmt.Println("Slice element type:", sliceType.Elem())     // int
    fmt.Println("Is variable sized?", sliceType.VariableLen()) // true
}
</code></pre>
<h3 id="1832-examining-struct-fields"><a class="header" href="#1832-examining-struct-fields"><strong>18.3.2 Examining Struct Fields</strong></a></h3>
<p>For struct types, <code>reflect.Type</code> provides methods to examine fields:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Address struct {
    Street string
    City   string
    ZIP    string
}

type Person struct {
    Name    string `json:"name" validate:"required"`
    Age     int    `json:"age" validate:"min=0,max=130"`
    Address Address
}

func main() {
    t := reflect.TypeOf(Person{})

    // Number of fields
    fmt.Println("Number of fields:", t.NumField()) // 3

    // Iterate through fields
    for i := 0; i &lt; t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("Field #%d: Name=%s, Type=%v, Tag=%v\n",
            i, field.Name, field.Type, field.Tag)
    }

    // Get field by name
    nameField, found := t.FieldByName("Name")
    if found {
        fmt.Println("\nFound Name field:")
        fmt.Println("JSON tag:", nameField.Tag.Get("json"))          // name
        fmt.Println("Validate tag:", nameField.Tag.Get("validate"))  // required
    }

    // Accessing nested fields
    addressField, _ := t.FieldByName("Address")
    addressType := addressField.Type
    for i := 0; i &lt; addressType.NumField(); i++ {
        field := addressType.Field(i)
        fmt.Printf("Address.%s: Type=%v\n", field.Name, field.Type)
    }
}
</code></pre>
<p>Output:</p>
<pre><code>Number of fields: 3
Field #0: Name=Name, Type=string, Tag=json:"name" validate:"required"
Field #1: Name=Age, Type=int, Tag=json:"age" validate:"min=0,max=130"
Field #2: Name=Address, Type=main.Address, Tag=

Found Name field:
JSON tag: name
Validate tag: required

Address.Street: Type=string
Address.City: Type=string
Address.ZIP: Type=string
</code></pre>
<h3 id="1833-examining-methods"><a class="header" href="#1833-examining-methods"><strong>18.3.3 Examining Methods</strong></a></h3>
<p><code>reflect.Type</code> also provides access to a type's methods:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Greeter struct {
    Greeting string
}

func (g Greeter) SayHello(name string) string {
    return g.Greeting + ", " + name
}

func (g *Greeter) SetGreeting(greeting string) {
    g.Greeting = greeting
}

func main() {
    // Value receiver type
    valueType := reflect.TypeOf(Greeter{})
    fmt.Printf("Methods on %s:\n", valueType)
    for i := 0; i &lt; valueType.NumMethod(); i++ {
        method := valueType.Method(i)
        fmt.Printf("  %s: %v\n", method.Name, method.Type)
    }

    // Pointer receiver type
    pointerType := reflect.TypeOf(&amp;Greeter{})
    fmt.Printf("\nMethods on %s:\n", pointerType)
    for i := 0; i &lt; pointerType.NumMethod(); i++ {
        method := pointerType.Method(i)
        fmt.Printf("  %s: %v\n", method.Name, method.Type)
    }

    // Get method by name
    sayHello, found := valueType.MethodByName("SayHello")
    if found {
        fmt.Printf("\nSayHello method: %v\n", sayHello.Type)
        // Method type includes receiver as first parameter
        fmt.Printf("Number of inputs: %d\n", sayHello.Type.NumIn())
        fmt.Printf("First input (receiver): %v\n", sayHello.Type.In(0))
        fmt.Printf("Second input: %v\n", sayHello.Type.In(1))
        fmt.Printf("Number of outputs: %d\n", sayHello.Type.NumOut())
        fmt.Printf("Output type: %v\n", sayHello.Type.Out(0))
    }
}
</code></pre>
<p>Output:</p>
<pre><code>Methods on main.Greeter:
  SayHello: func(main.Greeter, string) string

Methods on *main.Greeter:
  SayHello: func(*main.Greeter, string) string
  SetGreeting: func(*main.Greeter, string)

SayHello method: func(main.Greeter, string) string
Number of inputs: 2
First input (receiver): main.Greeter
Second input: string
Number of outputs: 1
Output type: string
</code></pre>
<p>Notice that the pointer type includes both methods, while the value type only includes the value receiver method.</p>
<h3 id="1834-type-comparisons-and-conversions"><a class="header" href="#1834-type-comparisons-and-conversions"><strong>18.3.4 Type Comparisons and Conversions</strong></a></h3>
<p><code>reflect.Type</code> provides methods for comparing types and checking for assignability and convertibility:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type MyInt int
type YourInt int

func main() {
    var i int = 42
    var mi MyInt = 42
    var yi YourInt = 42

    iType := reflect.TypeOf(i)
    miType := reflect.TypeOf(mi)
    yiType := reflect.TypeOf(yi)

    // Check if types are identical
    fmt.Println("int == MyInt?", iType == miType)                  // false
    fmt.Println("MyInt == YourInt?", miType == yiType)             // false

    // Check assignability (can a value of one type be assigned to a variable of another)
    fmt.Println("int assignable to MyInt?", iType.AssignableTo(miType))               // false
    fmt.Println("MyInt assignable to int?", miType.AssignableTo(iType))               // false
    fmt.Println("*MyInt assignable to *YourInt?", reflect.TypeOf(&amp;mi).AssignableTo(reflect.TypeOf(&amp;yi))) // false

    // Check convertibility (can a value be converted to another type)
    fmt.Println("int convertible to MyInt?", iType.ConvertibleTo(miType))            // true
    fmt.Println("MyInt convertible to YourInt?", miType.ConvertibleTo(yiType))       // true

    // Implement conversion
    miValue := reflect.ValueOf(mi)
    iValue := miValue.Convert(iType)
    fmt.Printf("Converted %v (%T) to %v (%T)\n",
        miValue.Interface(), miValue.Interface(),
        iValue.Interface(), iValue.Interface()) // Converted 42 (main.MyInt) to 42 (int)
}
</code></pre>
<h3 id="1835-working-with-array-slice-and-map-types"><a class="header" href="#1835-working-with-array-slice-and-map-types"><strong>18.3.5 Working with Array, Slice, and Map Types</strong></a></h3>
<p><code>reflect.Type</code> provides specific methods for array, slice, and map types:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

func main() {
    // Array
    arr := [3]int{1, 2, 3}
    arrType := reflect.TypeOf(arr)
    fmt.Printf("Array: Kind=%v, Len=%d, Elem=%v\n",
        arrType.Kind(), arrType.Len(), arrType.Elem())

    // Slice
    slice := []string{"a", "b", "c"}
    sliceType := reflect.TypeOf(slice)
    fmt.Printf("Slice: Kind=%v, Elem=%v\n",
        sliceType.Kind(), sliceType.Elem())

    // Map
    m := map[string]int{"a": 1, "b": 2}
    mapType := reflect.TypeOf(m)
    fmt.Printf("Map: Kind=%v, Key=%v, Elem=%v\n",
        mapType.Kind(), mapType.Key(), mapType.Elem())

    // Channel
    ch := make(chan int)
    chType := reflect.TypeOf(ch)
    fmt.Printf("Channel: Kind=%v, Dir=%v, Elem=%v\n",
        chType.Kind(), chType.ChanDir(), chType.Elem())

    // Function
    fn := func(a int, b string) float64 { return 0 }
    fnType := reflect.TypeOf(fn)
    fmt.Printf("Function: Kind=%v, NumIn=%d, NumOut=%d\n",
        fnType.Kind(), fnType.NumIn(), fnType.NumOut())
    for i := 0; i &lt; fnType.NumIn(); i++ {
        fmt.Printf("  In(%d): %v\n", i, fnType.In(i))
    }
    for i := 0; i &lt; fnType.NumOut(); i++ {
        fmt.Printf("  Out(%d): %v\n", i, fnType.Out(i))
    }
}
</code></pre>
<p>Output:</p>
<pre><code>Array: Kind=array, Len=3, Elem=int
Slice: Kind=slice, Elem=string
Map: Kind=map, Key=string, Elem=int
Channel: Kind=chan, Dir=both, Elem=int
Function: Kind=func, NumIn=2, NumOut=1
  In(0): int
  In(1): string
  Out(0): float64
</code></pre>
<h3 id="1836-creating-new-types-at-runtime"><a class="header" href="#1836-creating-new-types-at-runtime"><strong>18.3.6 Creating New Types at Runtime</strong></a></h3>
<p>The <code>reflect</code> package provides functions to create new types at runtime, which can be useful for dynamic code generation:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

func main() {
    // Create a slice type
    sliceType := reflect.SliceOf(reflect.TypeOf(0)) // []int
    fmt.Println("Created slice type:", sliceType)

    // Create a map type
    mapType := reflect.MapOf(reflect.TypeOf(""), reflect.TypeOf(0)) // map[string]int
    fmt.Println("Created map type:", mapType)

    // Create a channel type
    chanType := reflect.ChanOf(reflect.BothDir, reflect.TypeOf(0)) // chan int
    fmt.Println("Created channel type:", chanType)

    // Create an array type
    arrayType := reflect.ArrayOf(5, reflect.TypeOf("")) // [5]string
    fmt.Println("Created array type:", arrayType)

    // Create a pointer type
    ptrType := reflect.PtrTo(reflect.TypeOf(0)) // *int
    fmt.Println("Created pointer type:", ptrType)

    // Create a struct type
    fields := []reflect.StructField{
        {
            Name: "Name",
            Type: reflect.TypeOf(""),
            Tag:  reflect.StructTag(`json:"name"`),
        },
        {
            Name: "Age",
            Type: reflect.TypeOf(0),
            Tag:  reflect.StructTag(`json:"age"`),
        },
    }
    structType := reflect.StructOf(fields)
    fmt.Println("Created struct type:", structType)

    // Instantiate the struct type
    structValue := reflect.New(structType).Elem()
    structValue.Field(0).SetString("Alice")
    structValue.Field(1).SetInt(30)
    fmt.Printf("Created struct instance: %+v\n", structValue.Interface())
}
</code></pre>
<p>Output:</p>
<pre><code>Created slice type: []int
Created map type: map[string]int
Created channel type: chan int
Created array type: [5]string
Created pointer type: *int
Created struct type: struct { Name string "json:\"name\""; Age int "json:\"age\"" }
Created struct instance: {Name:Alice Age:30}
</code></pre>
<p>These functions allow us to create and manipulate types dynamically, which is particularly useful for code generation and generic programming.</p>
<h2 id="184-accessing-struct-fields-and-tags"><a class="header" href="#184-accessing-struct-fields-and-tags"><strong>18.4. Accessing Struct Fields and Tags</strong></a></h2>
<p>Reflection can be used to inspect and manipulate the fields of a struct, including reading and modifying struct tags. Struct tags are often used for purposes like JSON serialization.</p>
<h3 id="example-2-inspecting-struct-fields"><a class="header" href="#example-2-inspecting-struct-fields"><strong>Example 2: Inspecting Struct Fields</strong></a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name string `json:"name"`
    Age  int    `json:"age"`
}

func main() {
    p := Person{"Alice", 30}
    t := reflect.TypeOf(p)

    for i := 0; i &lt; t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("Field Name: %s, Type: %s, Tag: %s
", field.Name, field.Type, field.Tag)
    }
}
</code></pre>
<h4 id="explanation"><a class="header" href="#explanation"><strong>Explanation:</strong></a></h4>
<ul>
<li><code>t.NumField()</code> returns the number of fields in the struct.</li>
<li><code>t.Field(i)</code> returns metadata about the field, such as its name, type, and associated tags.</li>
<li>In this example, we inspect the <code>Person</code> struct, printing its fields, types, and tags.</li>
</ul>
<h4 id="output"><a class="header" href="#output"><strong>Output:</strong></a></h4>
<pre><code>Field Name: Name, Type: string, Tag: json:"name"
Field Name: Age, Type: int, Tag: json:"age"
</code></pre>
<h2 id="185-setting-values-dynamically"><a class="header" href="#185-setting-values-dynamically"><strong>18.5. Setting Values Dynamically</strong></a></h2>
<p>Reflection in Go allows you to modify variables dynamically at runtime. This can be useful when dealing with struct fields whose names and types are unknown at compile time.</p>
<h3 id="example-3-modifying-struct-fields"><a class="header" href="#example-3-modifying-struct-fields"><strong>Example 3: Modifying Struct Fields</strong></a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{"Alice", 30}
    v := reflect.ValueOf(&amp;p).Elem()

    // Modify fields
    v.FieldByName("Name").SetString("Bob")
    v.FieldByName("Age").SetInt(40)

    fmt.Println("Updated Struct:", p)
}
</code></pre>
<h4 id="explanation-1"><a class="header" href="#explanation-1"><strong>Explanation:</strong></a></h4>
<ul>
<li><code>reflect.ValueOf(&amp;p).Elem()</code> is used to get the address of the struct and modify its fields.</li>
<li><code>FieldByName("Name")</code> retrieves the field by its name and allows modification using methods like <code>SetString</code> and <code>SetInt</code>.</li>
</ul>
<h4 id="output-1"><a class="header" href="#output-1"><strong>Output:</strong></a></h4>
<pre><code>Updated Struct: {Bob 40}
</code></pre>
<h2 id="186-checking-and-invoking-methods-dynamically"><a class="header" href="#186-checking-and-invoking-methods-dynamically"><strong>18.6. Checking and Invoking Methods Dynamically</strong></a></h2>
<p>Reflection can also be used to call methods on objects dynamically, which can be useful for cases like plugin systems or dynamic method dispatch.</p>
<h3 id="example-4-calling-methods-dynamically"><a class="header" href="#example-4-calling-methods-dynamically"><strong>Example 4: Calling Methods Dynamically</strong></a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Calculator struct{}

func (Calculator) Add(a, b int) int {
    return a + b
}

func main() {
    calc := Calculator{}
    method := reflect.ValueOf(calc).MethodByName("Add")
    result := method.Call([]reflect.Value{reflect.ValueOf(5), reflect.ValueOf(3)})
    fmt.Println("Result:", result[0].Int())
}
</code></pre>
<h4 id="explanation-2"><a class="header" href="#explanation-2"><strong>Explanation:</strong></a></h4>
<ul>
<li><code>reflect.ValueOf(calc).MethodByName("Add")</code> retrieves the method named "Add" from the <code>Calculator</code> type.</li>
<li><code>method.Call()</code> is used to call the method with the provided arguments. The result is returned as a <code>reflect.Value</code>.</li>
</ul>
<h4 id="output-2"><a class="header" href="#output-2"><strong>Output:</strong></a></h4>
<pre><code>Result: 8
</code></pre>
<h2 id="187-use-case-json-validator"><a class="header" href="#187-use-case-json-validator"><strong>18.7. Use Case: JSON Validator</strong></a></h2>
<p>Reflection is often used in Go for validating struct fields dynamically. For example, we can check for required fields using struct tags.</p>
<h3 id="example-5-validating-required-fields"><a class="header" href="#example-5-validating-required-fields"><strong>Example 5: Validating Required Fields</strong></a></h3>
<pre><code class="language-go">package main

import (
    "errors"
    "fmt"
    "reflect"
)

type User struct {
    Name  string `validate:"required"`
    Email string `validate:"required"`
    Age   int
}

func validateStruct(s interface{}) error {
    v := reflect.ValueOf(s)
    t := reflect.TypeOf(s)

    for i := 0; i &lt; t.NumField(); i++ {
        field := t.Field(i)
        tag := field.Tag.Get("validate")
        if tag == "required" &amp;&amp; v.Field(i).IsZero() {
            return errors.New(field.Name + " is required")
        }
    }
    return nil
}

func main() {
    user := User{Name: "Alice", Age: 30}
    err := validateStruct(user)
    if err != nil {
        fmt.Println("Validation error:", err)
    } else {
        fmt.Println("Validation passed")
    }
}
</code></pre>
<h4 id="explanation-3"><a class="header" href="#explanation-3"><strong>Explanation:</strong></a></h4>
<ul>
<li>The <code>validateStruct</code> function checks if any fields with the <code>validate:"required"</code> tag are empty.</li>
<li><code>v.Field(i).IsZero()</code> checks if the field has its zero value (i.e., it has not been set).</li>
</ul>
<h4 id="output-3"><a class="header" href="#output-3"><strong>Output:</strong></a></h4>
<pre><code>Validation error: Email is required
</code></pre>
<h2 id="188-reflection-limitations"><a class="header" href="#188-reflection-limitations"><strong>18.8. Reflection Limitations</strong></a></h2>
<p>While reflection is powerful, it comes with its own set of limitations:</p>
<ol>
<li><strong>Performance</strong>: Reflection is generally slower than directly accessing types and values. It should be used sparingly in performance-critical sections of your code.</li>
<li><strong>Complexity</strong>: Reflection-based code can be harder to understand and maintain due to its dynamic nature. It can also be error-prone because errors are often discovered only at runtime.</li>
</ol>
<h2 id="189-exercises"><a class="header" href="#189-exercises"><strong>18.9. Exercises</strong></a></h2>
<h2 id="exercise-1-inspecting-slice-elements"><a class="header" href="#exercise-1-inspecting-slice-elements"><strong>Exercise 1: Inspecting Slice Elements</strong></a></h2>
<p><strong>Problem</strong>: Write a program to inspect the type and value of each element in a slice dynamically.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

func inspectSlice(slice interface{}) {
    v := reflect.ValueOf(slice)
    if v.Kind() == reflect.Slice {
        for i := 0; i &lt; v.Len(); i++ {
            fmt.Printf("Element %d: Type = %s, Value = %v\n", i, v.Index(i).Type(), v.Index(i))
        }
    } else {
        fmt.Println("Provided input is not a slice")
    }
}

func main() {
    nums := []int{1, 2, 3}
    inspectSlice(nums)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Element 0: Type = int, Value = 1
Element 1: Type = int, Value = 2
Element 2: Type = int, Value = 3
</code></pre>
<hr />
<h2 id="exercise-2-copy-struct-fields-dynamically"><a class="header" href="#exercise-2-copy-struct-fields-dynamically"><strong>Exercise 2: Copy Struct Fields Dynamically</strong></a></h2>
<p><strong>Problem</strong>: Write a function that dynamically copies fields from one struct to another struct of the same type.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Name  string
    Email string
    Age   int
}

func copyStruct(src, dst interface{}) {
    srcVal := reflect.ValueOf(src)
    dstVal := reflect.ValueOf(dst).Elem()

    for i := 0; i &lt; srcVal.NumField(); i++ {
        dstVal.Field(i).Set(srcVal.Field(i))
    }
}

func main() {
    user1 := User{"Alice", "alice@example.com", 25}
    var user2 User
    copyStruct(user1, &amp;user2)
    fmt.Println("Copied Struct:", user2)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Copied Struct: {Alice alice@example.com 25}
</code></pre>
<hr />
<h2 id="exercise-3-setting-slice-values-dynamically"><a class="header" href="#exercise-3-setting-slice-values-dynamically"><strong>Exercise 3: Setting Slice Values Dynamically</strong></a></h2>
<p><strong>Problem</strong>: Create a function to set values in a slice using reflection.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

func setSliceValues(slice interface{}, values []interface{}) {
    v := reflect.ValueOf(slice).Elem()
    for i := 0; i &lt; len(values); i++ {
        v.Index(i).Set(reflect.ValueOf(values[i]))
    }
}

func main() {
    nums := make([]int, 3)
    setSliceValues(&amp;nums, []interface{}{10, 20, 30})
    fmt.Println("Updated Slice:", nums)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Updated Slice: [10 20 30]
</code></pre>
<hr />
<h2 id="exercise-4-validating-struct-tags"><a class="header" href="#exercise-4-validating-struct-tags"><strong>Exercise 4: Validating Struct Tags</strong></a></h2>
<p><strong>Problem</strong>: Write a function to validate struct fields based on custom tags.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Product struct {
    Name  string `validate:"required"`
    Price float64 `validate:"required"`
}

func validateStruct(s interface{}) {
    v := reflect.ValueOf(s)
    t := reflect.TypeOf(s)

    for i := 0; i &lt; t.NumField(); i++ {
        field := t.Field(i)
        if field.Tag.Get("validate") == "required" &amp;&amp; v.Field(i).IsZero() {
            fmt.Printf("Field %s is required\n", field.Name)
        }
    }
}

func main() {
    product := Product{Name: "Laptop"}
    validateStruct(product)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Field Price is required
</code></pre>
<hr />
<h2 id="exercise-5-inspecting-function-signatures"><a class="header" href="#exercise-5-inspecting-function-signatures"><strong>Exercise 5: Inspecting Function Signatures</strong></a></h2>
<p><strong>Problem</strong>: Write a program to inspect the parameters and return types of a function dynamically.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

func inspectFunction(fn interface{}) {
    t := reflect.TypeOf(fn)
    fmt.Println("Function Name:", t.Name())
    fmt.Println("Number of Parameters:", t.NumIn())
    fmt.Println("Number of Return Values:", t.NumOut())

    for i := 0; i &lt; t.NumIn(); i++ {
        fmt.Printf("Parameter %d: %s\n", i, t.In(i))
    }
    for i := 0; i &lt; t.NumOut(); i++ {
        fmt.Printf("Return Value %d: %s\n", i, t.Out(i))
    }
}

func add(a int, b int) int {
    return a + b
}

func main() {
    inspectFunction(add)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Function Name: add
Number of Parameters: 2
Number of Return Values: 1
Parameter 0: int
Parameter 1: int
Return Value 0: int
</code></pre>
<hr />
<h2 id="exercise-6-modifying-struct-values-dynamically"><a class="header" href="#exercise-6-modifying-struct-values-dynamically"><strong>Exercise 6: Modifying Struct Values Dynamically</strong></a></h2>
<p><strong>Problem</strong>: Modify struct field values dynamically using reflection.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Employee struct {
    Name string
    Age  int
}

func updateStructField(s interface{}, fieldName string, value interface{}) {
    v := reflect.ValueOf(s).Elem()
    v.FieldByName(fieldName).Set(reflect.ValueOf(value))
}

func main() {
    emp := Employee{Name: "John", Age: 30}
    updateStructField(&amp;emp, "Name", "Alice")
    updateStructField(&amp;emp, "Age", 40)
    fmt.Println("Updated Employee:", emp)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Updated Employee: {Alice 40}
</code></pre>
<hr />
<h2 id="exercise-7-json-validator"><a class="header" href="#exercise-7-json-validator"><strong>Exercise 7: JSON Validator</strong></a></h2>
<p><strong>Problem</strong>: Validate required JSON fields using struct tags and reflection.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Config struct {
    Host string `json:"host" validate:"required"`
    Port int    `json:"port"`
}

func validateJSON(config Config) {
    t := reflect.TypeOf(config)
    v := reflect.ValueOf(config)

    for i := 0; i &lt; t.NumField(); i++ {
        field := t.Field(i)
        if field.Tag.Get("validate") == "required" &amp;&amp; v.Field(i).IsZero() {
            fmt.Printf("Field %s is required\n", field.Name)
        }
    }
}

func main() {
    config := Config{Port: 8080}
    validateJSON(config)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Field Host is required
</code></pre>
<hr />
<h2 id="exercise-8-recursive-field-inspection"><a class="header" href="#exercise-8-recursive-field-inspection"><strong>Exercise 8: Recursive Field Inspection</strong></a></h2>
<p><strong>Problem</strong>: Write a program to recursively inspect all fields of a nested struct.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "reflect"
)

type Address struct {
    City string
    Zip  string
}

type Person struct {
    Name    string
    Age     int
    Address Address
}

func inspectStruct(s interface{}) {
    v := reflect.ValueOf(s)
    t := reflect.TypeOf(s)

    for i := 0; i &lt; t.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        fmt.Printf("Field %s: %v\n", field.Name, value)
        if value.Kind() == reflect.Struct {
            inspectStruct(value.Interface())
        }
    }
}

func main() {
    p := Person{Name: "Alice", Age: 30, Address: Address{City: "Wonderland", Zip: "12345"}}
    inspectStruct(p)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Field Name: Alice
Field Age: 30
Field Address: {Wonderland 12345}
Field City: Wonderland
Field Zip: 12345
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/Chapter-17-Interfaces.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/Chapter-19-Generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/Chapter-17-Interfaces.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/Chapter-19-Generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
