<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building RESTful APIs - Go Universe</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to Go programming language from basics to advanced topics">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go Universe</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe/edit/main/src/chapters/Chapter-21-Building-RESTful-APIs.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-21-building-restful-apis-in-go"><a class="header" href="#chapter-21-building-restful-apis-in-go"><strong>Chapter 21: Building RESTful APIs in Go</strong></a></h1>
<p>Go has established itself as an excellent language for building web services and RESTful APIs due to its performance, concurrency model, and simplicity. This chapter provides a comprehensive guide to building robust, scalable, and maintainable RESTful APIs in Go, covering everything from fundamental concepts to advanced patterns and best practices.</p>
<h2 id="211-introduction-to-restful-apis"><a class="header" href="#211-introduction-to-restful-apis"><strong>21.1 Introduction to RESTful APIs</strong></a></h2>
<h3 id="2111-what-is-rest"><a class="header" href="#2111-what-is-rest"><strong>21.1.1 What is REST?</strong></a></h3>
<p>REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs use HTTP requests to perform CRUD (Create, Read, Update, Delete) operations on resources, which are represented as URLs.</p>
<p>Key principles of REST include:</p>
<ol>
<li><strong>Statelessness</strong>: Each request contains all information needed to complete it</li>
<li><strong>Client-Server Architecture</strong>: Separation of concerns between client and server</li>
<li><strong>Cacheable</strong>: Responses must define themselves as cacheable or non-cacheable</li>
<li><strong>Uniform Interface</strong>: Resources are identified in requests, manipulated through representations, and include self-descriptive messages</li>
<li><strong>Layered System</strong>: A client cannot ordinarily tell whether it is connected directly to the end server</li>
<li><strong>Code on Demand</strong> (optional): Servers can extend client functionality by transferring executable code</li>
</ol>
<h3 id="2112-http-methods-and-rest"><a class="header" href="#2112-http-methods-and-rest"><strong>21.1.2 HTTP Methods and REST</strong></a></h3>
<p>The primary HTTP methods used in RESTful APIs:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Purpose</th><th>Idempotent</th><th>Safe</th></tr></thead><tbody>
<tr><td>GET</td><td>Retrieve a resource</td><td>Yes</td><td>Yes</td></tr>
<tr><td>POST</td><td>Create a resource</td><td>No</td><td>No</td></tr>
<tr><td>PUT</td><td>Update a resource (complete replacement)</td><td>Yes</td><td>No</td></tr>
<tr><td>PATCH</td><td>Partial update of a resource</td><td>No</td><td>No</td></tr>
<tr><td>DELETE</td><td>Remove a resource</td><td>Yes</td><td>No</td></tr>
<tr><td>HEAD</td><td>Retrieve headers only</td><td>Yes</td><td>Yes</td></tr>
<tr><td>OPTIONS</td><td>Get supported operations on a resource</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<h3 id="2113-api-design-principles"><a class="header" href="#2113-api-design-principles"><strong>21.1.3 API Design Principles</strong></a></h3>
<p>When designing RESTful APIs, follow these principles:</p>
<ol>
<li><strong>Use nouns, not verbs for resources</strong>: <code>/users</code>, not <code>/getUsers</code></li>
<li><strong>Use plural for collection resources</strong>: <code>/users</code>, not <code>/user</code></li>
<li><strong>Use HTTP methods appropriately</strong> for operations</li>
<li><strong>Use nested resources</strong> for relationships: <code>/users/123/orders</code></li>
<li><strong>Use appropriate HTTP status codes</strong></li>
<li><strong>Provide clear error messages</strong></li>
<li><strong>Implement pagination</strong> for large collections</li>
<li><strong>Support filtering, sorting, and searching</strong></li>
<li><strong>Version your API</strong>: <code>/v1/users</code></li>
<li><strong>Follow consistent naming conventions</strong></li>
</ol>
<h2 id="212-building-apis-with-standard-library"><a class="header" href="#212-building-apis-with-standard-library"><strong>21.2 Building APIs with Standard Library</strong></a></h2>
<p>Go's standard library provides all the tools needed to build RESTful APIs without external dependencies. Let's start by building a simple API using the standard library.</p>
<h3 id="2121-basic-http-server"><a class="header" href="#2121-basic-http-server"><strong>21.2.1 Basic HTTP Server</strong></a></h3>
<pre><code class="language-go">package main

import (
    "encoding/json"
    "log"
    "net/http"
)

// User represents a user in our system
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// Simple in-memory store for demonstration
var users = []User{
    {ID: 1, Username: "alice", Email: "alice@example.com"},
    {ID: 2, Username: "bob", Email: "bob@example.com"},
}

func main() {
    // Define routes
    http.HandleFunc("/users", handleUsers)
    http.HandleFunc("/users/", handleUser)

    // Start server
    log.Println("Server starting on port 8080...")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

// handleUsers handles GET and POST requests for the /users endpoint
func handleUsers(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        // Return all users
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(users)
    case http.MethodPost:
        // Create a new user
        var user User
        if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }

        // Set ID (in a real app, this would be generated)
        user.ID = len(users) + 1
        users = append(users, user)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

// handleUser handles GET, PUT and DELETE requests for /users/{id}
func handleUser(w http.ResponseWriter, r *http.Request) {
    // Extract ID from URL
    // URL format: /users/{id}
    id := r.URL.Path[len("/users/"):]
    if id == "" {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }

    // Find user by ID
    var foundUser User
    var found bool
    var index int

    // Simplified ID parsing for demo purposes
    idInt := 0
    _, err := fmt.Sscanf(id, "%d", &amp;idInt)
    if err != nil {
        http.Error(w, "Invalid user ID format", http.StatusBadRequest)
        return
    }

    for i, user := range users {
        if user.ID == idInt {
            foundUser = user
            found = true
            index = i
            break
        }
    }

    if !found {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }

    switch r.Method {
    case http.MethodGet:
        // Return the user
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(foundUser)
    case http.MethodPut:
        // Update the user
        var updatedUser User
        if err := json.NewDecoder(r.Body).Decode(&amp;updatedUser); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }

        // Preserve ID
        updatedUser.ID = foundUser.ID
        users[index] = updatedUser

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(updatedUser)
    case http.MethodDelete:
        // Delete the user
        users = append(users[:index], users[index+1:]...)
        w.WriteHeader(http.StatusNoContent)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
</code></pre>
<p>This basic example demonstrates:</p>
<ul>
<li>Defining routes and handling different HTTP methods</li>
<li>Working with JSON requests and responses</li>
<li>Basic error handling</li>
<li>In-memory data storage</li>
</ul>
<h3 id="2122-improved-router-with-servemux"><a class="header" href="#2122-improved-router-with-servemux"><strong>21.2.2 Improved Router with ServeMux</strong></a></h3>
<p>Go's standard <code>http.ServeMux</code> is simple but limited. Let's improve our routing:</p>
<pre><code class="language-go">package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "regexp"
    "strconv"
)

// User represents a user in our system
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// Simple in-memory store
var users = []User{
    {ID: 1, Username: "alice", Email: "alice@example.com"},
    {ID: 2, Username: "bob", Email: "bob@example.com"},
}

// Route struct to hold our route patterns
type Route struct {
    pattern *regexp.Regexp
    method  string
    handler http.HandlerFunc
}

// Routes slice to hold all routes
var routes []Route

// AddRoute registers a new route
func AddRoute(pattern string, method string, handler http.HandlerFunc) {
    routes = append(routes, Route{
        pattern: regexp.MustCompile("^" + pattern + "$"),
        method:  method,
        handler: handler,
    })
}

// Router dispatches requests to the appropriate handler
func Router(w http.ResponseWriter, r *http.Request) {
    for _, route := range routes {
        matches := route.pattern.FindStringSubmatch(r.URL.Path)
        if matches != nil &amp;&amp; (route.method == r.Method || route.method == "*") {
            route.handler(w, r)
            return
        }
    }
    http.NotFound(w, r)
}

func main() {
    // Register routes
    AddRoute("/users", http.MethodGet, getUsers)
    AddRoute("/users", http.MethodPost, createUser)
    AddRoute("/users/([0-9]+)", http.MethodGet, getUser)
    AddRoute("/users/([0-9]+)", http.MethodPut, updateUser)
    AddRoute("/users/([0-9]+)", http.MethodDelete, deleteUser)

    // Use our custom router
    http.HandleFunc("/", Router)

    // Start server
    log.Println("Server starting on port 8080...")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

// Get all users
func getUsers(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

// Create a new user
func createUser(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Set ID (in a real app, this would be generated)
    user.ID = len(users) + 1
    users = append(users, user)

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

// Get a single user
func getUser(w http.ResponseWriter, r *http.Request) {
    matches := regexp.MustCompile("^/users/([0-9]+)$").FindStringSubmatch(r.URL.Path)
    id, _ := strconv.Atoi(matches[1])

    for _, user := range users {
        if user.ID == id {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(user)
            return
        }
    }

    http.Error(w, "User not found", http.StatusNotFound)
}

// Update a user
func updateUser(w http.ResponseWriter, r *http.Request) {
    matches := regexp.MustCompile("^/users/([0-9]+)$").FindStringSubmatch(r.URL.Path)
    id, _ := strconv.Atoi(matches[1])

    var updatedUser User
    if err := json.NewDecoder(r.Body).Decode(&amp;updatedUser); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    for i, user := range users {
        if user.ID == id {
            // Preserve ID
            updatedUser.ID = id
            users[i] = updatedUser

            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(updatedUser)
            return
        }
    }

    http.Error(w, "User not found", http.StatusNotFound)
}

// Delete a user
func deleteUser(w http.ResponseWriter, r *http.Request) {
    matches := regexp.MustCompile("^/users/([0-9]+)$").FindStringSubmatch(r.URL.Path)
    id, _ := strconv.Atoi(matches[1])

    for i, user := range users {
        if user.ID == id {
            users = append(users[:i], users[i+1:]...)
            w.WriteHeader(http.StatusNoContent)
            return
        }
    }

    http.Error(w, "User not found", http.StatusNotFound)
}
</code></pre>
<p>This improved version includes:</p>
<ul>
<li>Regular expression-based routing</li>
<li>Separate handler functions for each operation</li>
<li>Better path parameter extraction</li>
</ul>
<h3 id="2123-middleware-in-go"><a class="header" href="#2123-middleware-in-go"><strong>21.2.3 Middleware in Go</strong></a></h3>
<p>Middleware functions intercept HTTP requests and responses to add common functionality:</p>
<pre><code class="language-go">package main

import (
    "encoding/json"
    "log"
    "net/http"
    "time"
)

// Middleware type definition
type Middleware func(http.HandlerFunc) http.HandlerFunc

// Chain applies middlewares to a handler function
func Chain(handler http.HandlerFunc, middlewares ...Middleware) http.HandlerFunc {
    for _, middleware := range middlewares {
        handler = middleware(handler)
    }
    return handler
}

// Logging middleware
func Logging() Middleware {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            next(w, r)
            log.Printf(
                "%s %s %s",
                r.Method,
                r.RequestURI,
                time.Since(start),
            )
        }
    }
}

// Authentication middleware (simplified)
func Authentication() Middleware {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            token := r.Header.Get("Authorization")
            if token == "" {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            // In a real app, validate the token here
            next(w, r)
        }
    }
}

// CORS middleware
func CORS() Middleware {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Access-Control-Allow-Origin", "*")
            w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
            w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

            if r.Method == http.MethodOptions {
                w.WriteHeader(http.StatusOK)
                return
            }

            next(w, r)
        }
    }
}

func main() {
    // Apply middleware to handlers
    http.HandleFunc("/users", Chain(
        handleUsers,
        Logging(),
        CORS(),
    ))

    // Protected route with authentication
    http.HandleFunc("/admin", Chain(
        handleAdmin,
        Logging(),
        CORS(),
        Authentication(),
    ))

    // Start server
    log.Println("Server starting on port 8080...")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

func handleUsers(w http.ResponseWriter, r *http.Request) {
    users := []map[string]interface{}{
        {"id": 1, "name": "Alice"},
        {"id": 2, "name": "Bob"},
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func handleAdmin(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "message": "Admin area accessed successfully",
    })
}
</code></pre>
<p>This example demonstrates:</p>
<ul>
<li>Creating reusable middleware</li>
<li>Chaining middleware together</li>
<li>Implementing common middleware patterns (logging, authentication, CORS)</li>
</ul>
<h3 id="2124-dependency-injection"><a class="header" href="#2124-dependency-injection"><strong>21.2.4 Dependency Injection</strong></a></h3>
<p>To improve testability and maintainability, let's refactor our API to use dependency injection:</p>
<pre><code class="language-go">package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
)

// User represents a user in our system
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// UserService handles user operations
type UserService interface {
    GetAll() ([]User, error)
    Get(id int) (User, error)
    Create(user User) (User, error)
    Update(id int, user User) (User, error)
    Delete(id int) error
}

// InMemoryUserService implements UserService with in-memory storage
type InMemoryUserService struct {
    users []User
    nextID int
}

// NewInMemoryUserService creates a new in-memory user service
func NewInMemoryUserService() *InMemoryUserService {
    return &amp;InMemoryUserService{
        users: []User{
            {ID: 1, Username: "alice", Email: "alice@example.com"},
            {ID: 2, Username: "bob", Email: "bob@example.com"},
        },
        nextID: 3,
    }
}

func (s *InMemoryUserService) GetAll() ([]User, error) {
    return s.users, nil
}

func (s *InMemoryUserService) Get(id int) (User, error) {
    for _, user := range s.users {
        if user.ID == id {
            return user, nil
        }
    }
    return User{}, fmt.Errorf("user with ID %d not found", id)
}

func (s *InMemoryUserService) Create(user User) (User, error) {
    user.ID = s.nextID
    s.nextID++
    s.users = append(s.users, user)
    return user, nil
}

func (s *InMemoryUserService) Update(id int, user User) (User, error) {
    for i, u := range s.users {
        if u.ID == id {
            user.ID = id
            s.users[i] = user
            return user, nil
        }
    }
    return User{}, fmt.Errorf("user with ID %d not found", id)
}

func (s *InMemoryUserService) Delete(id int) error {
    for i, user := range s.users {
        if user.ID == id {
            s.users = append(s.users[:i], s.users[i+1:]...)
            return nil
        }
    }
    return fmt.Errorf("user with ID %d not found", id)
}

// UserHandler handles HTTP requests for users
type UserHandler struct {
    service UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(service UserService) *UserHandler {
    return &amp;UserHandler{service: service}
}

func (h *UserHandler) GetUsers(w http.ResponseWriter, r *http.Request) {
    users, err := h.service.GetAll()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request, id int) {
    user, err := h.service.Get(id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    created, err := h.service.Create(user)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(created)
}

func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request, id int) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    updated, err := h.service.Update(id, user)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(updated)
}

func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request, id int) {
    if err := h.service.Delete(id); err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }

    w.WriteHeader(http.StatusNoContent)
}

func main() {
    // Create service and handler
    userService := NewInMemoryUserService()
    userHandler := NewUserHandler(userService)

    // Set up routes (simplified)
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case http.MethodGet:
            userHandler.GetUsers(w, r)
        case http.MethodPost:
            userHandler.CreateUser(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    })

    http.HandleFunc("/users/", func(w http.ResponseWriter, r *http.Request) {
        // Extract ID from URL (simplified)
        var id int
        _, err := fmt.Sscanf(r.URL.Path, "/users/%d", &amp;id)
        if err != nil {
            http.Error(w, "Invalid user ID", http.StatusBadRequest)
            return
        }

        switch r.Method {
        case http.MethodGet:
            userHandler.GetUser(w, r, id)
        case http.MethodPut:
            userHandler.UpdateUser(w, r, id)
        case http.MethodDelete:
            userHandler.DeleteUser(w, r, id)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    })

    // Start server
    log.Println("Server starting on port 8080...")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
</code></pre>
<p>The benefits of this approach include:</p>
<ul>
<li>Separation of concerns (handlers, services)</li>
<li>Improved testability via interfaces</li>
<li>Easier maintenance and future extension</li>
</ul>
<h3 id="2125-testing-restful-apis"><a class="header" href="#2125-testing-restful-apis"><strong>21.2.5 Testing RESTful APIs</strong></a></h3>
<p>Testing is crucial for API development. Let's look at testing our handlers:</p>
<pre><code class="language-go">package main

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
)

// MockUserService implements UserService for testing
type MockUserService struct {
    users []User
}

func NewMockUserService() *MockUserService {
    return &amp;MockUserService{
        users: []User{
            {ID: 1, Username: "testuser", Email: "test@example.com"},
        },
    }
}

func (s *MockUserService) GetAll() ([]User, error) {
    return s.users, nil
}

func (s *MockUserService) Get(id int) (User, error) {
    if id == 1 {
        return s.users[0], nil
    }
    return User{}, fmt.Errorf("user not found")
}

func (s *MockUserService) Create(user User) (User, error) {
    user.ID = 2
    return user, nil
}

func (s *MockUserService) Update(id int, user User) (User, error) {
    if id == 1 {
        user.ID = 1
        return user, nil
    }
    return User{}, fmt.Errorf("user not found")
}

func (s *MockUserService) Delete(id int) error {
    if id == 1 {
        return nil
    }
    return fmt.Errorf("user not found")
}

func TestGetUsers(t *testing.T) {
    // Setup
    mockService := NewMockUserService()
    handler := NewUserHandler(mockService)

    // Create request
    req, err := http.NewRequest(http.MethodGet, "/users", nil)
    if err != nil {
        t.Fatal(err)
    }

    // Create response recorder
    rr := httptest.NewRecorder()

    // Call the handler
    handler.GetUsers(rr, req)

    // Check status code
    if rr.Code != http.StatusOK {
        t.Errorf("expected status %d but got %d", http.StatusOK, rr.Code)
    }

    // Check response body
    var users []User
    if err := json.NewDecoder(rr.Body).Decode(&amp;users); err != nil {
        t.Fatal(err)
    }

    if len(users) != 1 {
        t.Errorf("expected 1 user but got %d", len(users))
    }

    if users[0].Username != "testuser" {
        t.Errorf("expected username 'testuser' but got '%s'", users[0].Username)
    }
}

func TestCreateUser(t *testing.T) {
    // Setup
    mockService := NewMockUserService()
    handler := NewUserHandler(mockService)

    // Create request body
    newUser := User{Username: "newuser", Email: "new@example.com"}
    body, _ := json.Marshal(newUser)

    // Create request
    req, err := http.NewRequest(http.MethodPost, "/users", bytes.NewBuffer(body))
    if err != nil {
        t.Fatal(err)
    }
    req.Header.Set("Content-Type", "application/json")

    // Create response recorder
    rr := httptest.NewRecorder()

    // Call the handler
    handler.CreateUser(rr, req)

    // Check status code
    if rr.Code != http.StatusCreated {
        t.Errorf("expected status %d but got %d", http.StatusCreated, rr.Code)
    }

    // Check response body
    var createdUser User
    if err := json.NewDecoder(rr.Body).Decode(&amp;createdUser); err != nil {
        t.Fatal(err)
    }

    if createdUser.ID != 2 {
        t.Errorf("expected ID 2 but got %d", createdUser.ID)
    }

    if createdUser.Username != "newuser" {
        t.Errorf("expected username 'newuser' but got '%s'", createdUser.Username)
    }
}
</code></pre>
<h3 id="2126-error-handling"><a class="header" href="#2126-error-handling"><strong>21.2.6 Error Handling</strong></a></h3>
<p>Consistent error handling is essential for a robust API:</p>
<pre><code class="language-go">package main

import (
    "encoding/json"
    "errors"
    "log"
    "net/http"
)

// APIError represents an API error
type APIError struct {
    Status  int    `json:"status"`
    Message string `json:"message"`
    Error   string `json:"error,omitempty"`
}

// ErrorResponse creates a standardized error response
func ErrorResponse(w http.ResponseWriter, status int, message string, err error) {
    apiError := APIError{
        Status:  status,
        Message: message,
    }

    if err != nil {
        apiError.Error = err.Error()
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(apiError)
}

// Custom error types
var (
    ErrNotFound     = errors.New("resource not found")
    ErrInvalidInput = errors.New("invalid input")
    ErrUnauthorized = errors.New("unauthorized")
    ErrForbidden    = errors.New("forbidden")
    ErrInternal     = errors.New("internal server error")
)

// UserHandler with improved error handling
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request, id int) {
    user, err := h.service.Get(id)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            ErrorResponse(w, http.StatusNotFound, "User not found", err)
        } else {
            log.Printf("Error retrieving user: %v", err)
            ErrorResponse(w, http.StatusInternalServerError, "Failed to retrieve user", nil)
        }
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// Middleware for error recovery
func Recovery(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic: %v", err)
                ErrorResponse(w, http.StatusInternalServerError, "An unexpected error occurred", nil)
            }
        }()
        next.ServeHTTP(w, r)
    })
}
</code></pre>
<p>Key aspects of good error handling:</p>
<ul>
<li>Consistent error response format</li>
<li>Appropriate HTTP status codes</li>
<li>Logging errors but not exposing internal details to clients</li>
<li>Recovery from panics</li>
<li>Custom error types for different scenarios</li>
</ul>
<h2 id="213-building-apis-with-web-frameworks"><a class="header" href="#213-building-apis-with-web-frameworks"><strong>21.3 Building APIs with Web Frameworks</strong></a></h2>
<p>While Go's standard library provides excellent tools for building APIs, web frameworks can simplify development by offering additional features and conveniences. We'll explore two popular frameworks: Fiber and Echo.</p>
<h3 id="2131-introduction-to-fiber"><a class="header" href="#2131-introduction-to-fiber"><strong>21.3.1 Introduction to Fiber</strong></a></h3>
<p>Fiber is a web framework inspired by Express.js, built on top of Fasthttp, which claims to be the fastest HTTP engine for Go.</p>
<p><strong>Key features of Fiber:</strong></p>
<ul>
<li>Express-like API (familiar for JavaScript developers)</li>
<li>Built-in middleware</li>
<li>Routing with route groups</li>
<li>Static file serving</li>
<li>Template engines</li>
<li>WebSocket support</li>
<li>Low memory footprint</li>
<li>High performance</li>
</ul>
<p>Let's reimplement our API using Fiber:</p>
<pre><code class="language-go">package main

import (
    "log"
    "strconv"

    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/cors"
    "github.com/gofiber/fiber/v2/middleware/logger"
    "github.com/gofiber/fiber/v2/middleware/recover"
)

// User represents a user in our system
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// UserService interface (same as before)
type UserService interface {
    GetAll() ([]User, error)
    Get(id int) (User, error)
    Create(user User) (User, error)
    Update(id int, user User) (User, error)
    Delete(id int) error
}

// InMemoryUserService implementation (same as before)
// ...

// UserHandler handles HTTP requests for users using Fiber
type UserHandler struct {
    service UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(service UserService) *UserHandler {
    return &amp;UserHandler{service: service}
}

// RegisterRoutes registers routes for the user handler
func (h *UserHandler) RegisterRoutes(app *fiber.App) {
    users := app.Group("/users")

    users.Get("/", h.GetUsers)
    users.Post("/", h.CreateUser)
    users.Get("/:id", h.GetUser)
    users.Put("/:id", h.UpdateUser)
    users.Delete("/:id", h.DeleteUser)
}

// GetUsers returns all users
func (h *UserHandler) GetUsers(c *fiber.Ctx) error {
    users, err := h.service.GetAll()
    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
            "error": "Failed to retrieve users",
        })
    }

    return c.JSON(users)
}

// GetUser returns a single user
func (h *UserHandler) GetUser(c *fiber.Ctx) error {
    id, err := strconv.Atoi(c.Params("id"))
    if err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Invalid user ID",
        })
    }

    user, err := h.service.Get(id)
    if err != nil {
        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
            "error": "User not found",
        })
    }

    return c.JSON(user)
}

// CreateUser creates a new user
func (h *UserHandler) CreateUser(c *fiber.Ctx) error {
    var user User
    if err := c.BodyParser(&amp;user); err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Invalid request body",
        })
    }

    created, err := h.service.Create(user)
    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
            "error": "Failed to create user",
        })
    }

    return c.Status(fiber.StatusCreated).JSON(created)
}

// UpdateUser updates an existing user
func (h *UserHandler) UpdateUser(c *fiber.Ctx) error {
    id, err := strconv.Atoi(c.Params("id"))
    if err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Invalid user ID",
        })
    }

    var user User
    if err := c.BodyParser(&amp;user); err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Invalid request body",
        })
    }

    updated, err := h.service.Update(id, user)
    if err != nil {
        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
            "error": "User not found",
        })
    }

    return c.JSON(updated)
}

// DeleteUser deletes a user
func (h *UserHandler) DeleteUser(c *fiber.Ctx) error {
    id, err := strconv.Atoi(c.Params("id"))
    if err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Invalid user ID",
        })
    }

    if err := h.service.Delete(id); err != nil {
        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
            "error": "User not found",
        })
    }

    return c.SendStatus(fiber.StatusNoContent)
}

func main() {
    // Create service
    userService := NewInMemoryUserService()
    userHandler := NewUserHandler(userService)

    // Create Fiber app
    app := fiber.New(fiber.Config{
        ErrorHandler: func(c *fiber.Ctx, err error) error {
            // Default error handler
            code := fiber.StatusInternalServerError

            if e, ok := err.(*fiber.Error); ok {
                // Override status code if it's a Fiber error
                code = e.Code
            }

            return c.Status(code).JSON(fiber.Map{
                "error": err.Error(),
            })
        },
    })

    // Add middlewares
    app.Use(logger.New())
    app.Use(recover.New())
    app.Use(cors.New())

    // Register routes
    userHandler.RegisterRoutes(app)

    // Start server
    log.Fatal(app.Listen(":8080"))
}
</code></pre>
<h3 id="2132-introduction-to-echo"><a class="header" href="#2132-introduction-to-echo"><strong>21.3.2 Introduction to Echo</strong></a></h3>
<p>Echo is another popular Go web framework focused on simplicity and performance.</p>
<p><strong>Key features of Echo:</strong></p>
<ul>
<li>Optimized router with zero dynamic memory allocation</li>
<li>Middleware support</li>
<li>Data binding and validation</li>
<li>Scalable architecture</li>
<li>Extensible with third-party packages</li>
<li>Context-based API</li>
<li>Data rendering</li>
</ul>
<p>Let's implement our API using Echo:</p>
<pre><code class="language-go">package main

import (
    "net/http"
    "strconv"

    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

// User model (same as before)
// UserService interface (same as before)
// InMemoryUserService implementation (same as before)

// UserHandler handles HTTP requests for users using Echo
type UserHandler struct {
    service UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(service UserService) *UserHandler {
    return &amp;UserHandler{service: service}
}

// RegisterRoutes registers routes for the user handler
func (h *UserHandler) RegisterRoutes(e *echo.Echo) {
    e.GET("/users", h.GetUsers)
    e.POST("/users", h.CreateUser)
    e.GET("/users/:id", h.GetUser)
    e.PUT("/users/:id", h.UpdateUser)
    e.DELETE("/users/:id", h.DeleteUser)
}

// GetUsers returns all users
func (h *UserHandler) GetUsers(c echo.Context) error {
    users, err := h.service.GetAll()
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to retrieve users",
        })
    }

    return c.JSON(http.StatusOK, users)
}

// GetUser returns a single user
func (h *UserHandler) GetUser(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid user ID",
        })
    }

    user, err := h.service.Get(id)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "User not found",
        })
    }

    return c.JSON(http.StatusOK, user)
}

// CreateUser creates a new user
func (h *UserHandler) CreateUser(c echo.Context) error {
    var user User
    if err := c.Bind(&amp;user); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid request body",
        })
    }

    created, err := h.service.Create(user)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to create user",
        })
    }

    return c.JSON(http.StatusCreated, created)
}

// UpdateUser updates an existing user
func (h *UserHandler) UpdateUser(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid user ID",
        })
    }

    var user User
    if err := c.Bind(&amp;user); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid request body",
        })
    }

    updated, err := h.service.Update(id, user)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "User not found",
        })
    }

    return c.JSON(http.StatusOK, updated)
}

// DeleteUser deletes a user
func (h *UserHandler) DeleteUser(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid user ID",
        })
    }

    if err := h.service.Delete(id); err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "User not found",
        })
    }

    return c.NoContent(http.StatusNoContent)
}

func main() {
    // Create service
    userService := NewInMemoryUserService()
    userHandler := NewUserHandler(userService)

    // Create Echo instance
    e := echo.New()

    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    e.Use(middleware.CORS())

    // Register routes
    userHandler.RegisterRoutes(e)

    // Start server
    e.Logger.Fatal(e.Start(":8080"))
}
</code></pre>
<h3 id="2133-framework-comparison-fiber-vs-echo"><a class="header" href="#2133-framework-comparison-fiber-vs-echo"><strong>21.3.3 Framework Comparison: Fiber vs. Echo</strong></a></h3>
<p>Both Fiber and Echo are excellent choices for building RESTful APIs in Go. Here's a comparison to help you choose:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Fiber</th><th>Echo</th></tr></thead><tbody>
<tr><td>Performance</td><td>Built on Fasthttp, very fast</td><td>Standard net/http, still fast</td></tr>
<tr><td>API Style</td><td>Express-like, familiar for JS devs</td><td>Context-based, similar to Gin</td></tr>
<tr><td>Memory Usage</td><td>Lower</td><td>Slightly higher</td></tr>
<tr><td>Maturity</td><td>Newer, growing community</td><td>Well-established, stable</td></tr>
<tr><td>Middleware</td><td>Rich ecosystem</td><td>Rich ecosystem</td></tr>
<tr><td>Learning Curve</td><td>Easy, especially for JS devs</td><td>Easy</td></tr>
<tr><td>Third-party Integration</td><td>Good</td><td>Excellent</td></tr>
<tr><td>Documentation</td><td>Good</td><td>Excellent</td></tr>
</tbody></table>
</div>
<p><strong>Recommendation:</strong></p>
<ul>
<li>Choose <strong>Fiber</strong> if you're coming from a Node.js/Express background, need maximum performance, or prefer an Express-like API.</li>
<li>Choose <strong>Echo</strong> if you prefer a more Go-idiomatic approach, need better third-party integration, or want a more established framework.</li>
</ul>
<p>For this chapter, we'll focus on Fiber for the remaining examples due to its performance advantages and growing popularity.</p>
<h3 id="2134-request-validation-with-fiber"><a class="header" href="#2134-request-validation-with-fiber"><strong>21.3.4 Request Validation with Fiber</strong></a></h3>
<p>Proper request validation is crucial for API security and reliability. Let's add validation to our Fiber implementation:</p>
<pre><code class="language-go">package main

import (
    "github.com/go-playground/validator/v10"
    "github.com/gofiber/fiber/v2"
)

// User with validation tags
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username" validate:"required,min=3,max=50"`
    Email    string `json:"email" validate:"required,email"`
    Age      int    `json:"age" validate:"gte=18,lte=120"`
}

// Validator instance
var validate = validator.New()

// Validation middleware
func ValidateUser(c *fiber.Ctx) error {
    var user User

    // Parse request body
    if err := c.BodyParser(&amp;user); err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Cannot parse JSON",
        })
    }

    // Validate user
    if err := validate.Struct(user); err != nil {
        errors := err.(validator.ValidationErrors)
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Validation failed",
            "details": formatValidationErrors(errors),
        })
    }

    // Set validated user to locals
    c.Locals("user", user)

    return c.Next()
}

// Format validation errors to be user-friendly
func formatValidationErrors(errors validator.ValidationErrors) map[string]string {
    errorMap := make(map[string]string)

    for _, err := range errors {
        field := err.Field()
        switch err.Tag() {
        case "required":
            errorMap[field] = field + " is required"
        case "email":
            errorMap[field] = field + " must be a valid email"
        case "min":
            errorMap[field] = field + " must be at least " + err.Param() + " characters"
        case "max":
            errorMap[field] = field + " must be at most " + err.Param() + " characters"
        case "gte":
            errorMap[field] = field + " must be greater than or equal to " + err.Param()
        case "lte":
            errorMap[field] = field + " must be less than or equal to " + err.Param()
        default:
            errorMap[field] = field + " is invalid"
        }
    }

    return errorMap
}

// Usage in route definition
users.Post("/", ValidateUser, h.CreateUser)
</code></pre>
<h3 id="2135-authentication-and-authorization"><a class="header" href="#2135-authentication-and-authorization"><strong>21.3.5 Authentication and Authorization</strong></a></h3>
<p>Let's implement JWT-based authentication with Fiber:</p>
<pre><code class="language-go">package main

import (
    "time"

    "github.com/gofiber/fiber/v2"
    jwtware "github.com/gofiber/jwt/v3"
    "github.com/golang-jwt/jwt/v4"
)

// JWT secret key
var jwtSecret = []byte("your-secret-key")

// Credentials for login
type Credentials struct {
    Username string `json:"username" validate:"required"`
    Password string `json:"password" validate:"required"`
}

// Claims represents JWT claims
type Claims struct {
    Username string `json:"username"`
    Admin    bool   `json:"admin"`
    jwt.RegisteredClaims
}

// AuthHandler handles authentication
type AuthHandler struct {
    // In a real app, use a user service to verify credentials
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler() *AuthHandler {
    return &amp;AuthHandler{}
}

// RegisterRoutes registers routes for the auth handler
func (h *AuthHandler) RegisterRoutes(app *fiber.App) {
    auth := app.Group("/auth")

    auth.Post("/login", h.Login)

    // Protected routes
    protected := app.Group("/protected")
    protected.Use(jwtware.New(jwtware.Config{
        SigningKey: jwtSecret,
        ErrorHandler: func(c *fiber.Ctx, err error) error {
            return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                "error": "Unauthorized",
            })
        },
    }))

    protected.Get("/", h.Protected)

    // Admin-only routes
    admin := app.Group("/admin")
    admin.Use(jwtware.New(jwtware.Config{
        SigningKey: jwtSecret,
    }))
    admin.Use(h.AdminOnly)

    admin.Get("/", h.AdminProtected)
}

// Login handles user login
func (h *AuthHandler) Login(c *fiber.Ctx) error {
    var credentials Credentials

    if err := c.BodyParser(&amp;credentials); err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
            "error": "Cannot parse JSON",
        })
    }

    // In a real app, verify credentials against database
    // This is a simplified example
    if credentials.Username != "admin" || credentials.Password != "password" {
        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
            "error": "Invalid credentials",
        })
    }

    // Determine if user is an admin (in a real app, check from database)
    isAdmin := credentials.Username == "admin"

    // Create token
    claims := Claims{
        Username: credentials.Username,
        Admin:    isAdmin,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * 24)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
            Issuer:    "api.example.com",
            Subject:   credentials.Username,
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    signedToken, err := token.SignedString(jwtSecret)
    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
            "error": "Could not generate token",
        })
    }

    return c.JSON(fiber.Map{
        "token": signedToken,
    })
}

// Protected route handler
func (h *AuthHandler) Protected(c *fiber.Ctx) error {
    user := c.Locals("user").(*jwt.Token)
    claims := user.Claims.(jwt.MapClaims)
    username := claims["username"].(string)

    return c.JSON(fiber.Map{
        "message": "Welcome " + username + "!",
    })
}

// AdminOnly middleware
func (h *AuthHandler) AdminOnly(c *fiber.Ctx) error {
    user := c.Locals("user").(*jwt.Token)
    claims := user.Claims.(jwt.MapClaims)

    if claims["admin"] != true {
        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
            "error": "Admin access required",
        })
    }

    return c.Next()
}

// AdminProtected route handler
func (h *AuthHandler) AdminProtected(c *fiber.Ctx) error {
    return c.JSON(fiber.Map{
        "message": "Welcome to the admin area!",
    })
}

// Usage in main function
func main() {
    app := fiber.New()

    // Register auth routes
    authHandler := NewAuthHandler()
    authHandler.RegisterRoutes(app)

    // ... other routes

    app.Listen(":8080")
}
</code></pre>
<h2 id="214-openapi-and-swagger-integration"><a class="header" href="#214-openapi-and-swagger-integration"><strong>21.4 OpenAPI and Swagger Integration</strong></a></h2>
<p>OpenAPI (formerly known as Swagger) is a specification for documenting RESTful APIs. Integrating OpenAPI with your Go API provides several benefits:</p>
<ul>
<li>Interactive API documentation</li>
<li>Client SDK generation</li>
<li>Server stub generation</li>
<li>API validation</li>
<li>API testing</li>
</ul>
<h3 id="2141-openapi-specification-basics"><a class="header" href="#2141-openapi-specification-basics"><strong>21.4.1 OpenAPI Specification Basics</strong></a></h3>
<p>The OpenAPI Specification (OAS) defines a standard, language-agnostic interface for RESTful APIs. Here's a simple example of an OpenAPI 3.0 document:</p>
<pre><code class="language-yaml">openapi: 3.0.0
info:
  title: User API
  description: API for managing users
  version: 1.0.0
servers:
  - url: http://localhost:8080
    description: Development server
paths:
  /users:
    get:
      summary: Get all users
      description: Returns a list of all users
      responses:
        "200":
          description: A list of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/User"
    post:
      summary: Create a new user
      description: Creates a new user with the provided information
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/NewUser"
      responses:
        "201":
          description: The created user
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "400":
          description: Bad request
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
  /users/{id}:
    get:
      summary: Get a user by ID
      description: Returns a single user by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        "200":
          description: A user
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "404":
          description: User not found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
    # ... PUT and DELETE operations ...
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        username:
          type: string
        email:
          type: string
      required:
        - id
        - username
        - email
    NewUser:
      type: object
      properties:
        username:
          type: string
          minLength: 3
          maxLength: 50
        email:
          type: string
          format: email
      required:
        - username
        - email
    Error:
      type: object
      properties:
        error:
          type: string
</code></pre>
<h3 id="2142-generating-openapi-documentation-with-swaggo"><a class="header" href="#2142-generating-openapi-documentation-with-swaggo"><strong>21.4.2 Generating OpenAPI Documentation with Swaggo</strong></a></h3>
<p>Swaggo is a tool that converts Go annotations to OpenAPI documentation. Let's integrate it with our Fiber API:</p>
<p>First, install Swaggo:</p>
<pre><code class="language-bash">go install github.com/swaggo/swag/cmd/swag@latest
</code></pre>
<p>Next, add annotations to your handlers:</p>
<pre><code class="language-go">package main

import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/swagger"
    _ "github.com/yourproject/docs" // Import generated docs
)

// @title User API
// @version 1.0
// @description API for managing users
// @BasePath /
func main() {
    // ... setup code ...
}

// UserHandler handles HTTP requests for users
type UserHandler struct {
    service UserService
}

// GetUsers returns all users
// @Summary Get all users
// @Description Returns a list of all users
// @Tags users
// @Accept json
// @Produce json
// @Success 200 {array} User
// @Failure 500 {object} ErrorResponse
// @Router /users [get]
func (h *UserHandler) GetUsers(c *fiber.Ctx) error {
    // ... implementation ...
}

// GetUser returns a single user
// @Summary Get a user by ID
// @Description Returns a single user by ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Success 200 {object} User
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Router /users/{id} [get]
func (h *UserHandler) GetUser(c *fiber.Ctx) error {
    // ... implementation ...
}

// CreateUser creates a new user
// @Summary Create a new user
// @Description Creates a new user with the provided information
// @Tags users
// @Accept json
// @Produce json
// @Param user body NewUser true "User information"
// @Success 201 {object} User
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users [post]
func (h *UserHandler) CreateUser(c *fiber.Ctx) error {
    // ... implementation ...
}
</code></pre>
<p>Generate the documentation:</p>
<pre><code class="language-bash">swag init
</code></pre>
<p>Add the Swagger UI to your Fiber app:</p>
<pre><code class="language-go">// Add Swagger documentation
app.Get("/swagger/*", swagger.HandlerDefault)
</code></pre>
<p>Now you can access the Swagger UI at <code>http://localhost:8080/swagger/index.html</code>.</p>
<h3 id="2143-openapi-client-generation"><a class="header" href="#2143-openapi-client-generation"><strong>21.4.3 OpenAPI Client Generation</strong></a></h3>
<p>Once you have an OpenAPI specification, you can generate client libraries in various languages using tools like OpenAPI Generator:</p>
<pre><code class="language-bash"># Install OpenAPI Generator
npm install @openapitools/openapi-generator-cli -g

# Generate TypeScript client
openapi-generator-cli generate -i swagger.json -g typescript-fetch -o ./client
</code></pre>
<p>Generated clients make it easier for frontend developers or API consumers to integrate with your API.</p>
<h3 id="2144-api-testing-with-openapi"><a class="header" href="#2144-api-testing-with-openapi"><strong>21.4.4 API Testing with OpenAPI</strong></a></h3>
<p>You can use the OpenAPI specification to automate API testing with tools like Postman or Dredd:</p>
<pre><code class="language-bash"># Install Dredd
npm install -g dredd

# Run tests
dredd openapi.yaml http://localhost:8080
</code></pre>
<p>This validates that your API implementation matches the specification.</p>
<h2 id="215-api-design-best-practices"><a class="header" href="#215-api-design-best-practices"><strong>21.5 API Design Best Practices</strong></a></h2>
<h3 id="2151-url-design"><a class="header" href="#2151-url-design"><strong>21.5.1 URL Design</strong></a></h3>
<p>Follow these guidelines for designing clean and intuitive URL structures:</p>
<ul>
<li>Use plural nouns for collections: <code>/users</code> instead of <code>/user</code></li>
<li>Use hierarchical relationships for nested resources: <code>/users/123/orders</code></li>
<li>Keep URLs simple and descriptive</li>
<li>Use kebab-case for multi-word resources: <code>/shipping-addresses</code></li>
<li>Use query parameters for filtering, sorting, and pagination: <code>/users?role=admin&amp;sort=name</code></li>
<li>Version your API: <code>/v1/users</code></li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code># Good
GET /v1/users
GET /v1/users/123
GET /v1/users/123/orders
GET /v1/users?role=admin

# Bad
GET /getUsers
GET /user/123
GET /userOrders/123
GET /v1/getAdminUsers
</code></pre>
<h3 id="2152-http-status-codes"><a class="header" href="#2152-http-status-codes"><strong>21.5.2 HTTP Status Codes</strong></a></h3>
<p>Use appropriate HTTP status codes to communicate the result of API requests:</p>
<div class="table-wrapper"><table><thead><tr><th>Code Range</th><th>Category</th><th>Common Codes</th></tr></thead><tbody>
<tr><td>2xx</td><td>Success</td><td>200 OK, 201 Created, 204 No Content</td></tr>
<tr><td>3xx</td><td>Redirection</td><td>301 Moved Permanently, 304 Not Modified</td></tr>
<tr><td>4xx</td><td>Client Error</td><td>400 Bad Request, 401 Unauthorized, 404 Not Found</td></tr>
<tr><td>5xx</td><td>Server Error</td><td>500 Internal Server Error, 503 Service Unavailable</td></tr>
</tbody></table>
</div>
<p><strong>Guidelines:</strong></p>
<ul>
<li>Use 200 for successful GET, PUT, and PATCH</li>
<li>Use 201 for successful POST that creates a resource</li>
<li>Use 204 for successful DELETE or operations with no response body</li>
<li>Use 400 for invalid request syntax</li>
<li>Use 401 for authentication failures</li>
<li>Use 403 for authorization failures</li>
<li>Use 404 when a resource doesn't exist</li>
<li>Use 500 for unexpected server errors</li>
</ul>
<h3 id="2153-response-structure"><a class="header" href="#2153-response-structure"><strong>21.5.3 Response Structure</strong></a></h3>
<p>Maintain consistent response structures:</p>
<pre><code class="language-json">// Success response
{
  "data": {
    "id": 123,
    "username": "alice",
    "email": "alice@example.com"
  },
  "meta": {
    "timestamp": "2023-04-01T12:00:00Z"
  }
}

// List response with pagination
{
  "data": [
    { "id": 1, "username": "alice" },
    { "id": 2, "username": "bob" }
  ],
  "meta": {
    "page": 1,
    "per_page": 10,
    "total": 42
  },
  "links": {
    "self": "/users?page=1",
    "next": "/users?page=2",
    "prev": null
  }
}

// Error response
{
  "error": {
    "code": "invalid_input",
    "message": "The request was invalid",
    "details": {
      "username": "Username is required"
    }
  }
}
</code></pre>
<h3 id="2154-api-security"><a class="header" href="#2154-api-security"><strong>21.5.4 API Security</strong></a></h3>
<p>Implement these security measures for your API:</p>
<ol>
<li><strong>Use HTTPS</strong>: Always serve your API over HTTPS to encrypt data in transit</li>
<li><strong>Authentication</strong>: Implement JWT, OAuth, or API keys</li>
<li><strong>Authorization</strong>: Restrict access based on user roles and permissions</li>
<li><strong>Rate Limiting</strong>: Protect against abuse and DoS attacks</li>
<li><strong>Input Validation</strong>: Validate all input to prevent injection attacks</li>
<li><strong>CORS Configuration</strong>: Control which domains can access your API</li>
<li><strong>Security Headers</strong>: Set appropriate headers like <code>Content-Security-Policy</code></li>
<li><strong>Error Handling</strong>: Don't leak sensitive information in error messages</li>
</ol>
<p>Example rate limiting with Fiber:</p>
<pre><code class="language-go">import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/limiter"
    "time"
)

app.Use(limiter.New(limiter.Config{
    Max:        100,
    Expiration: 1 * time.Minute,
    KeyGenerator: func(c *fiber.Ctx) string {
        return c.IP() // Rate limit by IP address
    },
    LimitReached: func(c *fiber.Ctx) error {
        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
            "error": "Rate limit exceeded",
        })
    },
}))
</code></pre>
<h3 id="2155-api-versioning"><a class="header" href="#2155-api-versioning"><strong>21.5.5 API Versioning</strong></a></h3>
<p>There are several approaches to API versioning:</p>
<ol>
<li>
<p><strong>URL Path Versioning</strong>: <code>/v1/users</code>, <code>/v2/users</code></p>
<ul>
<li>Pros: Simple, explicit, easy to browse</li>
<li>Cons: Not RESTful (resource shouldn't change based on version)</li>
</ul>
</li>
<li>
<p><strong>Query Parameter Versioning</strong>: <code>/users?version=1</code></p>
<ul>
<li>Pros: Maintains clean URLs</li>
<li>Cons: Optional parameters might be ignored</li>
</ul>
</li>
<li>
<p><strong>Header Versioning</strong>: <code>Accept: application/vnd.myapi.v1+json</code></p>
<ul>
<li>Pros: RESTful, doesn't pollute URL</li>
<li>Cons: Less visible, harder to test</li>
</ul>
</li>
<li>
<p><strong>Content Negotiation</strong>: <code>Accept: application/vnd.myapi+json;version=1.0</code></p>
<ul>
<li>Pros: Most RESTful approach</li>
<li>Cons: Complex, less common</li>
</ul>
</li>
</ol>
<p>URL path versioning is the most common approach due to its simplicity and visibility.</p>
<h3 id="2156-pagination-filtering-and-sorting"><a class="header" href="#2156-pagination-filtering-and-sorting"><strong>21.5.6 Pagination, Filtering, and Sorting</strong></a></h3>
<p>Implement these features for collections:</p>
<p><strong>Pagination:</strong></p>
<pre><code>GET /users?page=2&amp;per_page=10
</code></pre>
<p><strong>Filtering:</strong></p>
<pre><code>GET /users?role=admin&amp;status=active
</code></pre>
<p><strong>Sorting:</strong></p>
<pre><code>GET /users?sort=name&amp;order=asc
</code></pre>
<p><strong>Searching:</strong></p>
<pre><code>GET /users?q=alice
</code></pre>
<p>Example implementation with Fiber:</p>
<pre><code class="language-go">func (h *UserHandler) GetUsers(c *fiber.Ctx) error {
    // Pagination
    page, _ := strconv.Atoi(c.Query("page", "1"))
    perPage, _ := strconv.Atoi(c.Query("per_page", "10"))

    // Filtering
    role := c.Query("role")
    status := c.Query("status")

    // Sorting
    sort := c.Query("sort", "id")
    order := c.Query("order", "asc")

    // Search
    query := c.Query("q")

    // Get users with parameters
    users, total, err := h.service.GetUsers(UserFilter{
        Page:    page,
        PerPage: perPage,
        Role:    role,
        Status:  status,
        Sort:    sort,
        Order:   order,
        Query:   query,
    })

    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
            "error": "Failed to retrieve users",
        })
    }

    // Return paginated response
    return c.JSON(fiber.Map{
        "data": users,
        "meta": fiber.Map{
            "page":     page,
            "per_page": perPage,
            "total":    total,
        },
        "links": fiber.Map{
            "self": fmt.Sprintf("/users?page=%d", page),
            "next": page*perPage &lt; total ? fmt.Sprintf("/users?page=%d", page+1) : nil,
            "prev": page &gt; 1 ? fmt.Sprintf("/users?page=%d", page-1) : nil,
        },
    })
}
</code></pre>
<h3 id="2157-caching"><a class="header" href="#2157-caching"><strong>21.5.7 Caching</strong></a></h3>
<p>Implement caching to improve performance:</p>
<pre><code class="language-go">import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/cache"
    "time"
)

app.Use(cache.New(cache.Config{
    Next: func(c *fiber.Ctx) bool {
        return c.Query("refresh") == "true" // Skip cache if refresh is requested
    },
    Expiration: 30 * time.Minute,
    CacheControl: true,
}))
</code></pre>
<p>Also use HTTP caching headers:</p>
<pre><code class="language-go">func (h *UserHandler) GetUser(c *fiber.Ctx) error {
    // ... get user ...

    // Set cache headers
    c.Set("Cache-Control", "public, max-age=300")
    c.Set("ETag", calculateETag(user))

    return c.JSON(user)
}
</code></pre>
<h2 id="216-performance-optimization"><a class="header" href="#216-performance-optimization"><strong>21.6 Performance Optimization</strong></a></h2>
<h3 id="2161-database-optimization"><a class="header" href="#2161-database-optimization"><strong>21.6.1 Database Optimization</strong></a></h3>
<ul>
<li>Use connection pooling</li>
<li>Create appropriate indexes</li>
<li>Use query optimization</li>
<li>Implement database caching</li>
<li>Consider read replicas for scaling</li>
</ul>
<p>Example with connection pooling:</p>
<pre><code class="language-go">import (
    "database/sql"
    _ "github.com/lib/pq"
)

func initDB() *sql.DB {
    db, err := sql.Open("postgres", "postgres://user:password@localhost/dbname")
    if err != nil {
        log.Fatal(err)
    }

    // Configure connection pool
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(25)
    db.SetConnMaxLifetime(5 * time.Minute)

    return db
}
</code></pre>
<h3 id="2162-api-response-optimization"><a class="header" href="#2162-api-response-optimization"><strong>21.6.2 API Response Optimization</strong></a></h3>
<ul>
<li>Use compression</li>
<li>Implement response field filtering</li>
<li>Consider GraphQL for complex data requirements</li>
<li>Use streaming for large responses</li>
</ul>
<p>Example with Fiber compression:</p>
<pre><code class="language-go">import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/compress"
)

app.Use(compress.New(compress.Config{
    Level: compress.LevelBestSpeed,
}))
</code></pre>
<h3 id="2163-monitoring-and-profiling"><a class="header" href="#2163-monitoring-and-profiling"><strong>21.6.3 Monitoring and Profiling</strong></a></h3>
<p>Monitor your API performance:</p>
<pre><code class="language-go">import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/monitor"
    "github.com/gofiber/fiber/v2/middleware/pprof"
)

// Add metrics endpoint
app.Get("/metrics", monitor.New())

// Add pprof endpoints for profiling
app.Use(pprof.New())
</code></pre>
<h2 id="217-api-testing"><a class="header" href="#217-api-testing"><strong>21.7 API Testing</strong></a></h2>
<h3 id="2171-unit-testing"><a class="header" href="#2171-unit-testing"><strong>21.7.1 Unit Testing</strong></a></h3>
<p>Test individual components in isolation:</p>
<pre><code class="language-go">func TestUserService_Get(t *testing.T) {
    // Setup
    repo := &amp;MockUserRepository{
        users: map[int]User{
            1: {ID: 1, Username: "test", Email: "test@example.com"},
        },
    }
    service := NewUserService(repo)

    // Test
    user, err := service.Get(1)

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, 1, user.ID)
    assert.Equal(t, "test", user.Username)
}
</code></pre>
<h3 id="2172-integration-testing"><a class="header" href="#2172-integration-testing"><strong>21.7.2 Integration Testing</strong></a></h3>
<p>Test API endpoints with a test server:</p>
<pre><code class="language-go">func TestUserHandler_GetUser(t *testing.T) {
    // Setup
    app := setupTestApp()

    // Make request
    req := httptest.NewRequest("GET", "/users/1", nil)
    resp, err := app.Test(req)

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, fiber.StatusOK, resp.StatusCode)

    var user User
    json.NewDecoder(resp.Body).Decode(&amp;user)
    assert.Equal(t, 1, user.ID)
}
</code></pre>
<h3 id="2173-load-testing"><a class="header" href="#2173-load-testing"><strong>21.7.3 Load Testing</strong></a></h3>
<p>Use tools like k6, Apache JMeter, or Artillery for load testing:</p>
<pre><code class="language-js">// k6 script
import http from "k6/http";
import { check, sleep } from "k6";

export const options = {
  vus: 100,
  duration: "30s",
};

export default function () {
  const res = http.get("http://localhost:8080/users");
  check(res, {
    "status is 200": (r) =&gt; r.status === 200,
    "response time &lt; 200ms": (r) =&gt; r.timings.duration &lt; 200,
  });
  sleep(1);
}
</code></pre>
<h2 id="218-deployment-strategies"><a class="header" href="#218-deployment-strategies"><strong>21.8 Deployment Strategies</strong></a></h2>
<h3 id="2181-containerization-with-docker"><a class="header" href="#2181-containerization-with-docker"><strong>21.8.1 Containerization with Docker</strong></a></h3>
<p>Create a Dockerfile for your API:</p>
<pre><code class="language-dockerfile">FROM golang:1.18-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o api ./cmd/api

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/api .
COPY --from=builder /app/config ./config

EXPOSE 8080
CMD ["./api"]
</code></pre>
<h3 id="2182-orchestration-with-kubernetes"><a class="header" href="#2182-orchestration-with-kubernetes"><strong>21.8.2 Orchestration with Kubernetes</strong></a></h3>
<p>Deploy your API to Kubernetes:</p>
<pre><code class="language-yaml"># api-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
        - name: api
          image: yourregistry/api:latest
          ports:
            - containerPort: 8080
          resources:
            limits:
              cpu: "500m"
              memory: "512Mi"
            requests:
              cpu: "100m"
              memory: "256Mi"
          env:
            - name: DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: api-config
                  key: db_host
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10

---
# api-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: api
spec:
  selector:
    app: api
  ports:
    - port: 80
      targetPort: 8080
  type: ClusterIP
</code></pre>
<h3 id="2183-cicd-pipeline"><a class="header" href="#2183-cicd-pipeline"><strong>21.8.3 CI/CD Pipeline</strong></a></h3>
<p>Set up continuous integration and deployment:</p>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
name: Deploy API

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.18

      - name: Test
        run: go test -v ./...

      - name: Build Docker image
        run: docker build -t yourregistry/api:${{ github.sha }} .

      - name: Push Docker image
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push yourregistry/api:${{ github.sha }}

      - name: Deploy to Kubernetes
        uses: steebchen/kubectl@master
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        with:
          args: set image deployment/api api=yourregistry/api:${{ github.sha }}
</code></pre>
<h2 id="219-exercises"><a class="header" href="#219-exercises"><strong>21.9 Exercises</strong></a></h2>
<h3 id="exercise-1-basic-restful-api"><a class="header" href="#exercise-1-basic-restful-api"><strong>Exercise 1: Basic RESTful API</strong></a></h3>
<p>Build a simple RESTful API for a book management system using the standard library. Implement endpoints for creating, reading, updating, and deleting books.</p>
<h3 id="exercise-2-framework-based-api"><a class="header" href="#exercise-2-framework-based-api"><strong>Exercise 2: Framework-Based API</strong></a></h3>
<p>Rebuild the book management API using Fiber or Echo. Add middleware for logging, error handling, and authentication.</p>
<h3 id="exercise-3-openapi-documentation"><a class="header" href="#exercise-3-openapi-documentation"><strong>Exercise 3: OpenAPI Documentation</strong></a></h3>
<p>Add OpenAPI documentation to your book management API using Swaggo annotations and implement the Swagger UI.</p>
<h3 id="exercise-4-advanced-features"><a class="header" href="#exercise-4-advanced-features"><strong>Exercise 4: Advanced Features</strong></a></h3>
<p>Enhance your API with pagination, filtering, sorting, and caching. Implement proper error handling and validation.</p>
<h3 id="exercise-5-complete-api-project"><a class="header" href="#exercise-5-complete-api-project"><strong>Exercise 5: Complete API Project</strong></a></h3>
<p>Build a complete API project for a blog system with users, posts, and comments. Implement authentication, authorization, and all the best practices covered in this chapter.</p>
<h2 id="2110-summary"><a class="header" href="#2110-summary"><strong>21.10 Summary</strong></a></h2>
<p>In this chapter, we've covered comprehensive approaches to building RESTful APIs in Go:</p>
<ul>
<li><strong>Fundamentals</strong>: We explored the core principles of REST and API design</li>
<li><strong>Standard Library</strong>: We learned how to build APIs using Go's built-in http package</li>
<li><strong>Web Frameworks</strong>: We compared Fiber and Echo for building more feature-rich APIs</li>
<li><strong>OpenAPI</strong>: We integrated Swagger documentation for better API discoverability</li>
<li><strong>Best Practices</strong>: We covered URL design, status codes, response structures, and security</li>
<li><strong>Performance</strong>: We examined techniques for optimizing API performance</li>
<li><strong>Testing and Deployment</strong>: We explored strategies for testing and deploying APIs</li>
</ul>
<p>By following these patterns and practices, you can build robust, maintainable, and scalable RESTful APIs in Go that meet modern standards and deliver excellent performance.</p>
<p>The Go ecosystem offers excellent tools and libraries for API development, and the language's simplicity, performance, and concurrency model make it an ideal choice for building web services and APIs.</p>
<p><strong>Next Up</strong>: In the next chapter, we'll explore microservices architecture in Go, building on the API development concepts covered here.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/Chapter-20-Databases.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/Chapter-22-Microservices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/Chapter-20-Databases.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/Chapter-22-Microservices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
