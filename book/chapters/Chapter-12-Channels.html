<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Channels - Go Universe</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to Go programming language from basics to advanced topics">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go Universe</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/saeedalam/go-universe/edit/main/src/chapters/Chapter-12-Channels.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-12-channels-in-go"><a class="header" href="#chapter-12-channels-in-go"><strong>Chapter 12: Channels in Go</strong></a></h1>
<p>While Chapter 11 introduced goroutines and touched on channels as a way for goroutines to communicate, this chapter dives deeper into channels—one of Go's most powerful and distinctive features. Channels provide a way for goroutines to communicate and synchronize their execution without explicit locks or condition variables.</p>
<p>At their core, channels embody Go's concurrency philosophy: "Do not communicate by sharing memory; instead, share memory by communicating." This approach helps avoid many of the common pitfalls of concurrent programming while making code more readable and maintainable.</p>
<p>In this chapter, we'll explore the intricacies of Go channels, from basic operations to advanced patterns and best practices. You'll learn how to effectively leverage channels to build robust concurrent applications.</p>
<h2 id="121-channel-fundamentals"><a class="header" href="#121-channel-fundamentals"><strong>12.1 Channel Fundamentals</strong></a></h2>
<h3 id="1211-what-are-channels"><a class="header" href="#1211-what-are-channels"><strong>12.1.1 What Are Channels?</strong></a></h3>
<p>A channel in Go is a typed conduit through which you can send and receive values. It provides a way for goroutines to synchronize execution and communicate by passing data between them.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Create a channel for integers
    ch := make(chan int)

    // Start a goroutine to send a value
    go func() {
        ch &lt;- 42 // Send 42 to the channel
    }()

    // Receive the value from the channel
    value := &lt;-ch
    fmt.Println("Received:", value) // Output: Received: 42
}
</code></pre>
<p>Channels are first-class values that can be allocated, passed as arguments, stored in variables, and returned from functions. They are inherently synchronized, which means operations on them happen in a defined order.</p>
<h3 id="1212-channel-types-and-directionality"><a class="header" href="#1212-channel-types-and-directionality"><strong>12.1.2 Channel Types and Directionality</strong></a></h3>
<p>Channels can be declared with specific directionality constraints:</p>
<pre><code class="language-go">package main

import "fmt"

// Function that can only send to the channel
func sender(ch chan&lt;- int) {
    for i := 1; i &lt;= 5; i++ {
        ch &lt;- i
        fmt.Println("Sent:", i)
    }
    close(ch)
}

// Function that can only receive from the channel
func receiver(ch &lt;-chan int) {
    for val := range ch {
        fmt.Println("Received:", val)
    }
}

func main() {
    // Bidirectional channel
    ch := make(chan int)

    go sender(ch)  // Passed as send-only channel
    receiver(ch)   // Passed as receive-only channel
}
</code></pre>
<p>Channel directionality helps catch programming errors at compile time and documents how a channel is intended to be used:</p>
<ul>
<li><code>chan T</code>: Bidirectional channel (can send and receive values of type T)</li>
<li><code>chan&lt;- T</code>: Send-only channel (can only send values of type T)</li>
<li><code>&lt;-chan T</code>: Receive-only channel (can only receive values of type T)</li>
</ul>
<h3 id="1213-creating-and-closing-channels"><a class="header" href="#1213-creating-and-closing-channels"><strong>12.1.3 Creating and Closing Channels</strong></a></h3>
<p>Channels are created using the <code>make</code> function, and they can be closed when no more values will be sent:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Create an unbuffered channel
    unbuffered := make(chan int)

    // Create a buffered channel with capacity 5
    buffered := make(chan int, 5)

    // Using a channel
    go func() {
        for i := 1; i &lt;= 3; i++ {
            buffered &lt;- i
        }
        close(buffered) // Close the channel when done sending
    }()

    // Receive values until channel is closed
    for val := range buffered {
        fmt.Println("Value:", val)
    }

    // After the loop, the channel is known to be closed
    fmt.Println("Channel closed, loop exited")
}
</code></pre>
<p>Key points about closing channels:</p>
<ul>
<li>Only the sender should close a channel, never the receiver</li>
<li>Sending on a closed channel causes a panic</li>
<li>Receiving from a closed channel returns the zero value immediately</li>
<li>The second return value from a receive operation indicates whether the channel is still open</li>
</ul>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        ch &lt;- 42
        close(ch)
    }()

    // First receive - gets the value
    val, ok := &lt;-ch
    fmt.Printf("val: %d, open: %t\n", val, ok) // val: 42, open: true

    // Second receive - channel is closed
    val, ok = &lt;-ch
    fmt.Printf("val: %d, open: %t\n", val, ok) // val: 0, open: false
}
</code></pre>
<h3 id="1214-unbuffered-vs-buffered-channels"><a class="header" href="#1214-unbuffered-vs-buffered-channels"><strong>12.1.4 Unbuffered vs. Buffered Channels</strong></a></h3>
<p>Go supports both unbuffered and buffered channels, each with different synchronization behaviors:</p>
<p><strong>Unbuffered Channels:</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int) // Unbuffered channel

    go func() {
        fmt.Println("Sending value...")
        ch &lt;- 42
        fmt.Println("Value sent!")
    }()

    // Add a small delay to demonstrate the blocking nature
    time.Sleep(time.Second)
    fmt.Println("About to receive...")
    val := &lt;-ch
    fmt.Println("Received:", val)
}
</code></pre>
<p>With unbuffered channels, send operations block until there is a corresponding receive operation, and vice versa. This creates a perfect synchronization point between goroutines.</p>
<p><strong>Buffered Channels:</strong></p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int, 2) // Buffered channel with capacity 2

    go func() {
        for i := 1; i &lt;= 3; i++ {
            fmt.Println("Sending:", i)
            ch &lt;- i
            fmt.Println("Sent:", i)
        }
    }()

    // Wait to let the goroutine execute
    time.Sleep(time.Second)

    // Receive values
    for i := 1; i &lt;= 3; i++ {
        val := &lt;-ch
        fmt.Println("Received:", val)
    }
}
</code></pre>
<p>With buffered channels:</p>
<ul>
<li>Sends block only when the buffer is full</li>
<li>Receives block only when the buffer is empty</li>
<li>The buffer decouples the send and receive operations in time</li>
</ul>
<h2 id="122-channel-operations-and-patterns"><a class="header" href="#122-channel-operations-and-patterns"><strong>12.2 Channel Operations and Patterns</strong></a></h2>
<h3 id="1221-the-select-statement"><a class="header" href="#1221-the-select-statement"><strong>12.2.1 The Select Statement</strong></a></h3>
<p>The <code>select</code> statement lets a goroutine wait on multiple channel operations simultaneously:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    // Send on ch1 after 1 second
    go func() {
        time.Sleep(1 * time.Second)
        ch1 &lt;- "one"
    }()

    // Send on ch2 after 2 seconds
    go func() {
        time.Sleep(2 * time.Second)
        ch2 &lt;- "two"
    }()

    // Use select to wait on both channels
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-ch1:
            fmt.Println("Received from ch1:", msg1)
        case msg2 := &lt;-ch2:
            fmt.Println("Received from ch2:", msg2)
        }
    }
}
</code></pre>
<p>The <code>select</code> statement:</p>
<ul>
<li>Blocks until one of its cases can proceed</li>
<li>If multiple cases are ready, it chooses one at random</li>
<li>Can include a <code>default</code> case that executes immediately if no other case is ready</li>
</ul>
<h3 id="1222-non-blocking-channel-operations"><a class="header" href="#1222-non-blocking-channel-operations"><strong>12.2.2 Non-Blocking Channel Operations</strong></a></h3>
<p>The <code>select</code> statement with a <code>default</code> case allows for non-blocking channel operations:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan int)

    // Start a goroutine that will eventually send a value
    go func() {
        time.Sleep(2 * time.Second)
        ch &lt;- 42
    }()

    // Try to receive, but don't block
    select {
    case val := &lt;-ch:
        fmt.Println("Received:", val)
    default:
        fmt.Println("No value available yet")
    }

    // Wait a bit and try again
    time.Sleep(3 * time.Second)

    // Now the value should be available
    select {
    case val := &lt;-ch:
        fmt.Println("Received:", val)
    default:
        fmt.Println("No value available yet")
    }
}
</code></pre>
<p>Non-blocking operations are useful in scenarios where you want to check for channel activity without pausing the execution of your goroutine.</p>
<h3 id="1223-timeouts-with-channels"><a class="header" href="#1223-timeouts-with-channels"><strong>12.2.3 Timeouts with Channels</strong></a></h3>
<p>The <code>select</code> statement can implement timeouts using <code>time.After</code>:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    // Attempt an operation that might take too long
    go func() {
        time.Sleep(2 * time.Second)
        ch &lt;- "operation completed"
    }()

    // Wait for the operation with a timeout
    select {
    case result := &lt;-ch:
        fmt.Println("Success:", result)
    case &lt;-time.After(1 * time.Second):
        fmt.Println("Timeout: operation took too long")
    }
}
</code></pre>
<p>This pattern is useful for preventing a goroutine from blocking indefinitely when interacting with potentially slow or unresponsive operations.</p>
<h3 id="1224-cancellation-with-channels"><a class="header" href="#1224-cancellation-with-channels"><strong>12.2.4 Cancellation with Channels</strong></a></h3>
<p>Channels can be used to signal cancellation to goroutines:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func worker(done &lt;-chan bool) {
    go func() {
        for {
            select {
            case &lt;-done:
                fmt.Println("Worker: Received cancellation signal")
                return
            default:
                fmt.Println("Worker: Working...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()
}

func main() {
    done := make(chan bool)

    worker(done)

    // Let the worker run for 2 seconds
    time.Sleep(2 * time.Second)

    // Signal the worker to stop
    fmt.Println("Main: Sending cancellation signal")
    done &lt;- true

    // Give the worker time to exit
    time.Sleep(1 * time.Second)
    fmt.Println("Main: Exiting")
}
</code></pre>
<p>This pattern allows for graceful termination of goroutines when their work is no longer needed.</p>
<h3 id="1225-fan-out-fan-in-pattern"><a class="header" href="#1225-fan-out-fan-in-pattern"><strong>12.2.5 Fan-Out, Fan-In Pattern</strong></a></h3>
<p>The fan-out, fan-in pattern is a common way to parallelize work using channels:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

// Generate produces integers in a sequence
func generate(nums ...int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out &lt;- n
        }
    }()
    return out
}

// Square squares numbers from input channel and returns output channel
func square(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out &lt;- n * n
            time.Sleep(200 * time.Millisecond) // Simulate work
        }
    }()
    return out
}

// Merge consolidates multiple input channels into a single output channel
func merge(cs ...&lt;-chan int) &lt;-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    // Start output goroutine for each input channel
    output := func(c &lt;-chan int) {
        defer wg.Done()
        for n := range c {
            out &lt;- n
        }
    }

    wg.Add(len(cs))
    for _, c := range cs {
        go output(c)
    }

    // Start goroutine to close once all inputs are processed
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}

func main() {
    // Fan-out: distribute work across multiple goroutines
    in := generate(1, 2, 3, 4, 5)
    c1 := square(in)
    c2 := square(in)
    c3 := square(in)

    // Fan-in: consolidate results
    for n := range merge(c1, c2, c3) {
        fmt.Println(n)
    }
}
</code></pre>
<p>This pattern:</p>
<ul>
<li>Distributes work across multiple goroutines (fan-out)</li>
<li>Collects results from multiple goroutines into a single channel (fan-in)</li>
<li>Is particularly useful for CPU-bound tasks that can be parallelized</li>
</ul>
<h1 id="129-exercises"><a class="header" href="#129-exercises"><strong>12.9. Exercises</strong></a></h1>
<hr />
<h2 id="exercise-1-basic-channel-communication"><a class="header" href="#exercise-1-basic-channel-communication"><strong>Exercise 1: Basic Channel Communication</strong></a></h2>
<p><strong>Problem</strong>: Create a channel and send a message from one goroutine to another.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan string)

    go func() {
        ch &lt;- "Hello from goroutine!"
    }()

    msg := &lt;-ch
    fmt.Println(msg)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Hello from goroutine!
</code></pre>
<hr />
<h2 id="exercise-2-buffered-channel"><a class="header" href="#exercise-2-buffered-channel"><strong>Exercise 2: Buffered Channel</strong></a></h2>
<p><strong>Problem</strong>: Use a buffered channel to send and receive multiple values.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan int, 3)
    ch &lt;- 10
    ch &lt;- 20
    ch &lt;- 30

    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>10
20
30
</code></pre>
<hr />
<h2 id="exercise-3-closing-a-channel"><a class="header" href="#exercise-3-closing-a-channel"><strong>Exercise 3: Closing a Channel</strong></a></h2>
<p><strong>Problem</strong>: Close a channel and iterate over its values using <code>range</code>.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch := make(chan int)

    go func() {
        for i := 0; i &lt; 5; i++ {
            ch &lt;- i
        }
        close(ch)
    }()

    for val := range ch {
        fmt.Println(val)
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>0
1
2
3
4
</code></pre>
<hr />
<h2 id="exercise-4-using-select-statement"><a class="header" href="#exercise-4-using-select-statement"><strong>Exercise 4: Using <code>select</code> Statement</strong></a></h2>
<p><strong>Problem</strong>: Use the <code>select</code> statement to read from multiple channels.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() { ch1 &lt;- "Message from ch1" }()
    go func() { ch2 &lt;- "Message from ch2" }()

    select {
    case msg1 := &lt;-ch1:
        fmt.Println(msg1)
    case msg2 := &lt;-ch2:
        fmt.Println(msg2)
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Message from ch1
</code></pre>
<p>(Note: The output depends on which channel is ready first.)</p>
<hr />
<h2 id="exercise-5-implementing-a-timeout"><a class="header" href="#exercise-5-implementing-a-timeout"><strong>Exercise 5: Implementing a Timeout</strong></a></h2>
<p><strong>Problem</strong>: Use <code>time.After</code> to add a timeout when waiting for channel data.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    go func() {
        time.Sleep(2 * time.Second)
        ch &lt;- "Data received"
    }()

    select {
    case msg := &lt;-ch:
        fmt.Println(msg)
    case &lt;-time.After(1 * time.Second):
        fmt.Println("Timeout")
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Timeout
</code></pre>
<hr />
<h2 id="exercise-6-fan-out-pattern"><a class="header" href="#exercise-6-fan-out-pattern"><strong>Exercise 6: Fan-Out Pattern</strong></a></h2>
<p><strong>Problem</strong>: Use multiple goroutines to send data into a channel.</p>
<pre><code class="language-go">package main

import "fmt"

func worker(id int, ch chan string) {
    ch &lt;- fmt.Sprintf("Worker %d: task completed", id)
}

func main() {
    ch := make(chan string, 3)

    for i := 1; i &lt;= 3; i++ {
        go worker(i, ch)
    }

    for i := 1; i &lt;= 3; i++ {
        fmt.Println(&lt;-ch)
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Worker 1: task completed
Worker 2: task completed
Worker 3: task completed
</code></pre>
<hr />
<h2 id="exercise-7-fan-in-pattern"><a class="header" href="#exercise-7-fan-in-pattern"><strong>Exercise 7: Fan-In Pattern</strong></a></h2>
<p><strong>Problem</strong>: Combine data from multiple channels into a single channel.</p>
<pre><code class="language-go">package main

import "fmt"

func producer(ch chan string, msg string) {
    for i := 0; i &lt; 3; i++ {
        ch &lt;- fmt.Sprintf("%s %d", msg, i)
    }
    close(ch)
}

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    result := make(chan string)

    go producer(ch1, "Producer 1")
    go producer(ch2, "Producer 2")

    go func() {
        for msg := range ch1 {
            result &lt;- msg
        }
        for msg := range ch2 {
            result &lt;- msg
        }
        close(result)
    }()

    for msg := range result {
        fmt.Println(msg)
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Producer 1 0
Producer 1 1
Producer 1 2
Producer 2 0
Producer 2 1
Producer 2 2
</code></pre>
<hr />
<h2 id="exercise-8-worker-pool"><a class="header" href="#exercise-8-worker-pool"><strong>Exercise 8: Worker Pool</strong></a></h2>
<p><strong>Problem</strong>: Implement a worker pool using channels.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d
", id, job)
        results &lt;- job * 2
    }
}

func main() {
    const numJobs = 5
    const numWorkers = 3

    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)

    var wg sync.WaitGroup
    for w := 1; w &lt;= numWorkers; w++ {
        wg.Add(1)
        go func(id int) {
            worker(id, jobs, results)
            wg.Done()
        }(w)
    }

    for j := 1; j &lt;= numJobs; j++ {
        jobs &lt;- j
    }
    close(jobs)

    wg.Wait()
    close(results)

    for result := range results {
        fmt.Println("Result:", result)
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Worker 1 processing job 1
Worker 2 processing job 2
Worker 3 processing job 3
Worker 1 processing job 4
Worker 2 processing job 5
Result: 2
Result: 4
Result: 6
Result: 8
Result: 10
</code></pre>
<hr />
<h2 id="exercise-9-broadcast-pattern"><a class="header" href="#exercise-9-broadcast-pattern"><strong>Exercise 9: Broadcast Pattern</strong></a></h2>
<p><strong>Problem</strong>: Use one channel to broadcast messages to multiple goroutines.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func listener(id int, ch &lt;-chan string) {
    for msg := range ch {
        fmt.Printf("Listener %d received: %s
", id, msg)
    }
}

func main() {
    ch := make(chan string)
    var wg sync.WaitGroup

    for i := 1; i &lt;= 3; i++ {
        wg.Add(1)
        go func(id int) {
            listener(id, ch)
            wg.Done()
        }(i)
    }

    for i := 1; i &lt;= 5; i++ {
        ch &lt;- fmt.Sprintf("Broadcast message %d", i)
    }
    close(ch)

    wg.Wait()
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Listener 1 received: Broadcast message 1
Listener 2 received: Broadcast message 2
Listener 3 received: Broadcast message 3
...
</code></pre>
<hr />
<h2 id="exercise-10-alternating-between-channels"><a class="header" href="#exercise-10-alternating-between-channels"><strong>Exercise 10: Alternating Between Channels</strong></a></h2>
<p><strong>Problem</strong>: Use <code>select</code> to alternate between two channels.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    go func() {
        for i := 0; i &lt; 5; i++ {
            ch1 &lt;- i
        }
        close(ch1)
    }()

    go func() {
        for i := 5; i &lt; 10; i++ {
            ch2 &lt;- i
        }
        close(ch2)
    }()

    for {
        select {
        case val, ok := &lt;-ch1:
            if ok {
                fmt.Println("From ch1:", val)
            }
        case val, ok := &lt;-ch2:
            if ok {
                fmt.Println("From ch2:", val)
            }
        }
        if len(ch1) == 0 &amp;&amp; len(ch2) == 0 {
            break
        }
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>From ch1: 0
From ch1: 1
...
From ch2: 9
</code></pre>
<hr />
<h2 id="123-advanced-channel-patterns"><a class="header" href="#123-advanced-channel-patterns"><strong>12.3 Advanced Channel Patterns</strong></a></h2>
<h3 id="1231-the-pipeline-pattern"><a class="header" href="#1231-the-pipeline-pattern"><strong>12.3.1 The Pipeline Pattern</strong></a></h3>
<p>Pipelines are a powerful pattern for processing data through a series of stages. Each stage receives values from an upstream stage, processes them, and sends the results to a downstream stage.</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

// Stage 1: Generate integers
func gen(nums ...int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out &lt;- n
        }
    }()
    return out
}

// Stage 2: Square the numbers
func sq(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out &lt;- n * n
        }
    }()
    return out
}

// Stage 3: Filter out odd numbers
func filter(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out &lt;- n
            }
        }
    }()
    return out
}

func main() {
    // Set up the pipeline
    c1 := gen(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    c2 := sq(c1)
    c3 := filter(c2)

    // Consume the output
    for n := range c3 {
        fmt.Println(n)
    }
}
</code></pre>
<p>Key properties of the pipeline pattern:</p>
<ul>
<li>Each stage closes its output channel when it's done sending</li>
<li>Each stage continues to receive values from upstream until the channel is closed</li>
<li>Each stage is an independent goroutine, enabling concurrent processing</li>
</ul>
<h3 id="1232-worker-pools-with-done-channels"><a class="header" href="#1232-worker-pools-with-done-channels"><strong>12.3.2 Worker Pools with Done Channels</strong></a></h3>
<p>Worker pools can be enhanced with cancellation signals to clean up resources properly:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, jobs &lt;-chan int, results chan&lt;- int, done &lt;-chan struct{}) {
    for {
        select {
        case job, ok := &lt;-jobs:
            if !ok {
                return // Channel closed
            }
            fmt.Printf("Worker %d started job %d\n", id, job)
            time.Sleep(500 * time.Millisecond) // Simulate work
            fmt.Printf("Worker %d finished job %d\n", id, job)
            results &lt;- job * 2
        case &lt;-done:
            fmt.Printf("Worker %d shutting down\n", id)
            return
        }
    }
}

func main() {
    jobs := make(chan int, 10)
    results := make(chan int, 10)
    done := make(chan struct{})

    // Start 3 workers
    var wg sync.WaitGroup
    for i := 1; i &lt;= 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            worker(id, jobs, results, done)
        }(i)
    }

    // Send 5 jobs
    for j := 1; j &lt;= 5; j++ {
        jobs &lt;- j
    }

    // Collect the results in a separate goroutine
    go func() {
        for result := range results {
            fmt.Println("Result:", result)
        }
    }()

    // Simulate some work, then trigger cancellation
    time.Sleep(2 * time.Second)
    fmt.Println("Sending cancellation signal")
    close(done)

    // Wait for all workers to exit
    wg.Wait()
    fmt.Println("All workers have terminated")
}
</code></pre>
<p>This pattern ensures proper cleanup of goroutines and resources when operations need to be cancelled.</p>
<h3 id="1233-context-for-cancellation"><a class="header" href="#1233-context-for-cancellation"><strong>12.3.3 Context for Cancellation</strong></a></h3>
<p>Go's <code>context</code> package provides a more structured way to handle cancellation:</p>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Printf("Worker %d: Stopping due to cancellation\n", id)
            return
        default:
            fmt.Printf("Worker %d: Working...\n", id)
            time.Sleep(1 * time.Second)
        }
    }
}

func main() {
    // Create a context with cancellation capability
    ctx, cancel := context.WithCancel(context.Background())

    // Start workers
    for i := 1; i &lt;= 3; i++ {
        go worker(ctx, i)
    }

    // Let workers run for 3 seconds
    time.Sleep(3 * time.Second)

    // Trigger cancellation
    fmt.Println("Main: Cancelling workers")
    cancel()

    // Give workers time to respond to cancellation
    time.Sleep(1 * time.Second)
    fmt.Println("Main: Done")
}
</code></pre>
<p>The <code>context</code> package provides several ways to create contexts with different cancellation behaviors:</p>
<ul>
<li><code>WithCancel</code>: Manual cancellation</li>
<li><code>WithDeadline</code>: Cancellation at a specific time</li>
<li><code>WithTimeout</code>: Cancellation after a duration</li>
<li><code>WithValue</code>: Carries request-scoped values across API boundaries</li>
</ul>
<h3 id="1234-rate-limiting-with-buffered-channels"><a class="header" href="#1234-rate-limiting-with-buffered-channels"><strong>12.3.4 Rate Limiting with Buffered Channels</strong></a></h3>
<p>Channels can be used to implement rate limiting:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    // Create a channel to serve as our rate limiter
    // By using a buffered channel of size 3, we allow
    // up to 3 operations to happen concurrently
    limiter := make(chan struct{}, 3)

    // Simulate 10 requests
    for i := 1; i &lt;= 10; i++ {
        // Acquire a token from the rate limiter
        limiter &lt;- struct{}{}

        go func(id int) {
            defer func() {
                // Release the token when done
                &lt;-limiter
            }()

            fmt.Printf("Request %d starting at %s\n",
                       id, time.Now().Format("15:04:05.000"))

            // Simulate work
            time.Sleep(2 * time.Second)

            fmt.Printf("Request %d completed at %s\n",
                       id, time.Now().Format("15:04:05.000"))
        }(i)
    }

    // Wait for all goroutines to finish
    time.Sleep(10 * time.Second)
}
</code></pre>
<p>This pattern limits the number of concurrent operations, which is useful for preventing resource exhaustion.</p>
<h2 id="124-common-channel-patterns"><a class="header" href="#124-common-channel-patterns"><strong>12.4 Common Channel Patterns</strong></a></h2>
<h3 id="1241-generator-pattern"><a class="header" href="#1241-generator-pattern"><strong>12.4.1 Generator Pattern</strong></a></h3>
<p>The generator pattern produces a sequence of values:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

// Simple generator - returns a receive-only channel
func fibonacci() &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        a, b := 0, 1
        for i := 0; i &lt; 10; i++ {
            out &lt;- a
            a, b = b, a+b
            time.Sleep(300 * time.Millisecond) // Simulate work
        }
    }()
    return out
}

func main() {
    fmt.Println("Fibonacci sequence:")
    for num := range fibonacci() {
        fmt.Println(num)
    }
}
</code></pre>
<p>This pattern is useful for producing sequences, streams of data, or events.</p>
<h3 id="1242-futurepromise-pattern"><a class="header" href="#1242-futurepromise-pattern"><strong>12.4.2 Future/Promise Pattern</strong></a></h3>
<p>Channels can implement a future/promise pattern:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

// Future represents a value that will be available in the future
type Future struct {
    result &lt;-chan int
}

// NewFuture creates a new Future for a computation
func NewFuture(fn func() int) Future {
    result := make(chan int, 1) // Buffered to avoid goroutine leak

    go func() {
        result &lt;- fn() // Compute and send the result
        close(result)
    }()

    return Future{result: result}
}

// Get returns the result, blocking if necessary
func (f Future) Get() int {
    return &lt;-f.result
}

// Expensive computation
func compute(val int) int {
    fmt.Printf("Computing with value %d...\n", val)
    time.Sleep(2 * time.Second) // Simulate expensive computation
    return val * val
}

func main() {
    // Start computation in the background
    future := NewFuture(func() int {
        return compute(42)
    })

    fmt.Println("Future created, doing other work...")
    time.Sleep(1 * time.Second) // Do other work

    // Get the result when needed
    fmt.Println("Waiting for result...")
    result := future.Get()
    fmt.Println("Result:", result)
}
</code></pre>
<p>This pattern allows you to start a computation in the background and retrieve the result when needed.</p>
<h3 id="1243-pub-sub-pattern"><a class="header" href="#1243-pub-sub-pattern"><strong>12.4.3 Pub-Sub Pattern</strong></a></h3>
<p>A simple publish-subscribe pattern using channels:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

// Message represents a message in the pub-sub system
type Message struct {
    Topic   string
    Payload string
}

// PubSub implements a simple publish-subscribe pattern
type PubSub struct {
    mu          sync.RWMutex
    subscribers map[string][]chan Message
}

// NewPubSub creates a new PubSub instance
func NewPubSub() *PubSub {
    return &amp;PubSub{
        subscribers: make(map[string][]chan Message),
    }
}

// Subscribe creates a subscription to a topic
func (ps *PubSub) Subscribe(topic string) &lt;-chan Message {
    ps.mu.Lock()
    defer ps.mu.Unlock()

    ch := make(chan Message, 10)
    ps.subscribers[topic] = append(ps.subscribers[topic], ch)
    return ch
}

// Publish sends a message to all subscribers of a topic
func (ps *PubSub) Publish(topic, payload string) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()

    msg := Message{Topic: topic, Payload: payload}
    for _, ch := range ps.subscribers[topic] {
        // Non-blocking send to avoid slow subscribers
        // causing publishers to block
        select {
        case ch &lt;- msg:
        default:
            // Channel buffer full, message dropped
        }
    }
}

func main() {
    ps := NewPubSub()

    // Subscribe to topics
    ch1 := ps.Subscribe("topic1")
    ch2 := ps.Subscribe("topic1")
    ch3 := ps.Subscribe("topic2")

    // Start subscribers
    var wg sync.WaitGroup
    wg.Add(3)

    go func() {
        defer wg.Done()
        for msg := range ch1 {
            fmt.Printf("Subscriber 1 received [%s]: %s\n",
                       msg.Topic, msg.Payload)
        }
    }()

    go func() {
        defer wg.Done()
        for msg := range ch2 {
            fmt.Printf("Subscriber 2 received [%s]: %s\n",
                       msg.Topic, msg.Payload)
        }
    }()

    go func() {
        defer wg.Done()
        for msg := range ch3 {
            fmt.Printf("Subscriber 3 received [%s]: %s\n",
                       msg.Topic, msg.Payload)
        }
    }()

    // Publish messages
    ps.Publish("topic1", "Hello from topic1")
    ps.Publish("topic2", "Hello from topic2")
    ps.Publish("topic1", "Another message for topic1")

    // Wait a bit for messages to be processed
    time.Sleep(1 * time.Second)
}
</code></pre>
<p>This pattern allows for decoupled communication between components, where publishers don't need to know about subscribers and vice versa.</p>
<h2 id="125-channel-best-practices"><a class="header" href="#125-channel-best-practices"><strong>12.5 Channel Best Practices</strong></a></h2>
<h3 id="1251-ownership-and-directionality"><a class="header" href="#1251-ownership-and-directionality"><strong>12.5.1 Ownership and Directionality</strong></a></h3>
<p>Clear ownership and directionality make channel-based code easier to understand and maintain:</p>
<ol>
<li>
<p><strong>Establish Clear Ownership</strong></p>
<ul>
<li>Clearly define which goroutine owns each channel</li>
<li>The owner is responsible for creating, closing, and writing to the channel</li>
<li>Non-owners should only read from the channel</li>
</ul>
</li>
<li>
<p><strong>Use Channel Direction Constraints</strong></p>
<ul>
<li>Functions that only receive from a channel should use <code>&lt;-chan T</code></li>
<li>Functions that only send to a channel should use <code>chan&lt;- T</code></li>
<li>This documents intent and catches errors at compile time</li>
</ul>
</li>
</ol>
<pre><code class="language-go">package main

import "fmt"

// Producer owns the channel and is responsible for closing it
func producer(count int) &lt;-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch) // Owner is responsible for closing
        for i := 0; i &lt; count; i++ {
            ch &lt;- i
        }
    }()
    return ch
}

// Consumer only reads from the channel
func consumer(ch &lt;-chan int) {
    for val := range ch {
        fmt.Println("Received:", val)
    }
}

func main() {
    // Producer owns the channel
    ch := producer(5)

    // Consumer reads from the channel
    consumer(ch)
}
</code></pre>
<h3 id="1252-closing-channels"><a class="header" href="#1252-closing-channels"><strong>12.5.2 Closing Channels</strong></a></h3>
<p>Follow these guidelines when closing channels:</p>
<ol>
<li>
<p><strong>Only the Sender Should Close</strong></p>
<ul>
<li>Closing a channel indicates "no more values will be sent"</li>
<li>Only the sender (owner) should close a channel</li>
<li>Never close a channel from the receiver side</li>
</ul>
</li>
<li>
<p><strong>Don't Close a Channel Multiple Times</strong></p>
<ul>
<li>Closing an already closed channel causes a panic</li>
<li>Use sync primitives if multiple goroutines might close the same channel</li>
</ul>
</li>
<li>
<p><strong>Use Defer for Reliable Closing</strong></p>
<ul>
<li>In complex functions, use <code>defer close(ch)</code> to ensure the channel is closed</li>
</ul>
</li>
</ol>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // GOOD: Single owner closing the channel
    ch := make(chan int)
    go func() {
        defer close(ch) // Ensures channel is closed even if panic occurs
        for i := 0; i &lt; 5; i++ {
            ch &lt;- i
        }
    }()

    // Safely consume from the channel
    for val := range ch {
        fmt.Println(val)
    }

    // BAD: Multiple closers (would cause panic)
    /*
    ch2 := make(chan int)
    go func() { close(ch2) }()
    go func() { close(ch2) }() // PANIC: close of closed channel
    */
}
</code></pre>
<h3 id="1253-buffer-size-considerations"><a class="header" href="#1253-buffer-size-considerations"><strong>12.5.3 Buffer Size Considerations</strong></a></h3>
<p>Choose buffer sizes carefully:</p>
<ol>
<li>
<p><strong>Unbuffered Channels (Size 0)</strong></p>
<ul>
<li>Provide synchronization guarantees</li>
<li>Sender blocks until receiver is ready</li>
<li>Good for coordinating goroutines</li>
</ul>
</li>
<li>
<p><strong>Small Buffered Channels (Size 1-10)</strong></p>
<ul>
<li>Help smooth out bursts of activity</li>
<li>Reduce goroutine blocking</li>
<li>Good for producer-consumer patterns with varying speeds</li>
</ul>
</li>
<li>
<p><strong>Large Buffered Channels</strong></p>
<ul>
<li>Should be used with caution</li>
<li>May mask underlying performance issues</li>
<li>Consider using for known batch sizes or to absorb known spikes</li>
</ul>
</li>
</ol>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func main() {
    // Unbuffered: synchronization
    synch := make(chan int)
    go func() {
        fmt.Println("Sender: About to send")
        synch &lt;- 42
        fmt.Println("Sender: Value sent")
    }()
    time.Sleep(1 * time.Second)
    fmt.Println("Receiver: About to receive")
    &lt;-synch
    fmt.Println("Receiver: Received value")

    // Small buffer: smooth bursts
    burst := make(chan int, 3)
    go func() {
        for i := 0; i &lt; 5; i++ {
            fmt.Printf("Sending value %d\n", i)
            burst &lt;- i
        }
        close(burst)
    }()

    // Simulate slow consumer
    for val := range burst {
        fmt.Printf("Received value %d\n", val)
        time.Sleep(300 * time.Millisecond)
    }
}
</code></pre>
<h3 id="1254-error-handling-with-channels"><a class="header" href="#1254-error-handling-with-channels"><strong>12.5.4 Error Handling with Channels</strong></a></h3>
<p>Handle errors gracefully in channel-based code:</p>
<ol>
<li>
<p><strong>Include Error Information in Results</strong></p>
<ul>
<li>Create struct types that include both results and errors</li>
<li>Send these structs through channels</li>
</ul>
</li>
<li>
<p><strong>Use Separate Error Channels</strong></p>
<ul>
<li>For critical errors that require immediate attention</li>
<li>Or when error handling is complex</li>
</ul>
</li>
</ol>
<pre><code class="language-go">package main

import (
    "errors"
    "fmt"
    "math/rand"
    "time"
)

// Result combines a value and possible error
type Result struct {
    Value int
    Err   error
}

func worker(id int) &lt;-chan Result {
    results := make(chan Result)

    go func() {
        defer close(results)

        // Simulate work with possible errors
        time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)

        if rand.Float32() &lt; 0.3 { // 30% chance of error
            results &lt;- Result{
                Err: errors.New(fmt.Sprintf("worker %d failed", id)),
            }
            return
        }

        results &lt;- Result{
            Value: id * 10,
            Err:   nil,
        }
    }()

    return results
}

func main() {
    rand.Seed(time.Now().UnixNano())

    // Launch several workers
    workers := 5
    results := make([]&lt;-chan Result, workers)
    for i := 0; i &lt; workers; i++ {
        results[i] = worker(i)
    }

    // Process results, handling errors
    for i, ch := range results {
        result := &lt;-ch
        if result.Err != nil {
            fmt.Printf("Error from worker %d: %v\n", i, result.Err)
            continue
        }
        fmt.Printf("Worker %d returned: %d\n", i, result.Value)
    }
}
</code></pre>
<h2 id="126-exercises"><a class="header" href="#126-exercises"><strong>12.6 Exercises</strong></a></h2>
<h3 id="exercise-1-basic-channel-operations"><a class="header" href="#exercise-1-basic-channel-operations"><strong>Exercise 1: Basic Channel Operations</strong></a></h3>
<p>Create a program that starts multiple goroutines which communicate through channels.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func sender(ch chan&lt;- string) {
    // TODO: Send three different messages to the channel
    // with a short delay between each message
    // Don't forget to close the channel when done
}

func receiver(ch &lt;-chan string) {
    // TODO: Receive and print all messages from the channel
    // until the channel is closed
}

func main() {
    // TODO:
    // 1. Create a channel
    // 2. Start the sender and receiver goroutines
    // 3. Wait for them to finish
}

// Solution:
/*
package main

import (
    "fmt"
    "time"
)

func sender(ch chan&lt;- string) {
    for i := 1; i &lt;= 3; i++ {
        msg := fmt.Sprintf("Message %d", i)
        ch &lt;- msg
        fmt.Println("Sent:", msg)
        time.Sleep(100 * time.Millisecond)
    }
    close(ch)
    fmt.Println("Sender: closed channel")
}

func receiver(ch &lt;-chan string) {
    for msg := range ch {
        fmt.Println("Received:", msg)
    }
    fmt.Println("Receiver: channel closed")
}

func main() {
    ch := make(chan string)
    go sender(ch)
    receiver(ch)
}
*/
</code></pre>
<h3 id="exercise-2-implementing-a-pipeline"><a class="header" href="#exercise-2-implementing-a-pipeline"><strong>Exercise 2: Implementing a Pipeline</strong></a></h3>
<p>Create a pipeline that generates numbers, filters out odd numbers, and then squares the remaining even numbers.</p>
<pre><code class="language-go">package main

import (
    "fmt"
)

// TODO:
// 1. Implement a generator function that sends numbers 1-10 to a channel
// 2. Implement a filter function that receives numbers and sends only even numbers
// 3. Implement a square function that receives numbers and sends their squares
// 4. Connect these functions into a pipeline in the main function

// Solution:
/*
package main

import (
    "fmt"
)

func generate(n int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := 1; i &lt;= n; i++ {
            out &lt;- i
        }
    }()
    return out
}

func filterEven(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out &lt;- n
            }
        }
    }()
    return out
}

func square(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out &lt;- n * n
        }
    }()
    return out
}

func main() {
    // Set up the pipeline
    nums := generate(10)
    evens := filterEven(nums)
    squares := square(evens)

    // Consume the final output
    fmt.Println("Squares of even numbers:")
    for n := range squares {
        fmt.Println(n)
    }
}
*/
</code></pre>
<h3 id="exercise-3-fan-out-fan-in"><a class="header" href="#exercise-3-fan-out-fan-in"><strong>Exercise 3: Fan-Out, Fan-In</strong></a></h3>
<p>Implement a fan-out, fan-in pattern to process a list of numbers concurrently.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

// TODO:
// 1. Implement a function that generates numbers 1-10
// 2. Implement a function that processes a number (e.g., calculates factorial)
// 3. Implement the fan-out logic to distribute work
// 4. Implement the fan-in logic to collect results
// 5. Connect these in the main function

// Solution:
/*
package main

import (
    "fmt"
    "sync"
    "time"
)

// Generates numbers 1-10
func generator() &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := 1; i &lt;= 10; i++ {
            out &lt;- i
        }
    }()
    return out
}

// Calculates factorial of a number
func processor(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            // Simulate CPU-intensive work
            time.Sleep(100 * time.Millisecond)
            result := 1
            for i := 2; i &lt;= n; i++ {
                result *= i
            }
            out &lt;- result
        }
    }()
    return out
}

// Merges multiple channels into one
func fanIn(channels ...&lt;-chan int) &lt;-chan int {
    var wg sync.WaitGroup
    merged := make(chan int)

    // Start an output goroutine for each input channel
    wg.Add(len(channels))
    for _, ch := range channels {
        go func(c &lt;-chan int) {
            defer wg.Done()
            for n := range c {
                merged &lt;- n
            }
        }(ch)
    }

    // Start a goroutine to close merged once all inputs are done
    go func() {
        wg.Wait()
        close(merged)
    }()

    return merged
}

func main() {
    // Source channel
    source := generator()

    // Fan-out to 3 workers
    workers := 3
    channels := make([]&lt;-chan int, workers)
    for i := 0; i &lt; workers; i++ {
        channels[i] = processor(source)
    }

    // Fan-in the results
    results := fanIn(channels...)

    // Collect and print results
    for result := range results {
        fmt.Println("Result:", result)
    }
}
*/
</code></pre>
<h3 id="exercise-4-timeout-and-select"><a class="header" href="#exercise-4-timeout-and-select"><strong>Exercise 4: Timeout and Select</strong></a></h3>
<p>Create a function that fetches data from multiple sources with a timeout.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "math/rand"
    "time"
)

// TODO:
// 1. Create functions that simulate fetching data from different sources
// 2. Use select to handle timeouts and receive from the first available source
// 3. If all sources time out, return an error message

// Solution:
/*
package main

import (
    "fmt"
    "math/rand"
    "time"
)

// Simulate fetching data from a source with variable response time
func fetchData(source string) &lt;-chan string {
    ch := make(chan string)
    go func() {
        // Simulate variable response time (0-3 seconds)
        delay := time.Duration(rand.Intn(3000)) * time.Millisecond
        fmt.Printf("Source %s will respond in %v\n", source, delay)
        time.Sleep(delay)
        ch &lt;- fmt.Sprintf("Data from source %s", source)
    }()
    return ch
}

func fetchWithTimeout() (string, error) {
    // Set up sources
    source1 := fetchData("A")
    source2 := fetchData("B")
    source3 := fetchData("C")

    // Create a timeout
    timeout := time.After(2 * time.Second)

    // Wait for the first result or timeout
    select {
    case data := &lt;-source1:
        return data, nil
    case data := &lt;-source2:
        return data, nil
    case data := &lt;-source3:
        return data, nil
    case &lt;-timeout:
        return "", fmt.Errorf("all sources timed out")
    }
}

func main() {
    rand.Seed(time.Now().UnixNano())

    fmt.Println("Fetching data...")
    data, err := fetchWithTimeout()
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Received:", data)
    }
}
*/
</code></pre>
<h3 id="exercise-5-rate-limiter"><a class="header" href="#exercise-5-rate-limiter"><strong>Exercise 5: Rate Limiter</strong></a></h3>
<p>Implement a rate limiter using channels to control the rate of requests.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

// TODO:
// 1. Implement a rate limiter that allows a maximum of N operations per second
// 2. Use it to control a series of worker goroutines
// 3. Demonstrate that the rate limiting is working as expected

// Solution:
/*
package main

import (
    "fmt"
    "sync"
    "time"
)

// RateLimiter allows a maximum of rate operations per interval
type RateLimiter struct {
    rate     int
    interval time.Duration
    tokens   chan struct{}
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(rate int, interval time.Duration) *RateLimiter {
    limiter := &amp;RateLimiter{
        rate:     rate,
        interval: interval,
        tokens:   make(chan struct{}, rate),
    }

    // Fill the token bucket
    for i := 0; i &lt; rate; i++ {
        limiter.tokens &lt;- struct{}{}
    }

    // Refill tokens at the specified rate
    go func() {
        ticker := time.NewTicker(interval / time.Duration(rate))
        defer ticker.Stop()

        for range ticker.C {
            select {
            case limiter.tokens &lt;- struct{}{}:
                // Added a token
            default:
                // Bucket is full
            }
        }
    }()

    return limiter
}

// Wait blocks until a token is available
func (rl *RateLimiter) Wait() {
    &lt;-rl.tokens
}

func main() {
    // Create a rate limiter: 3 operations per second
    limiter := NewRateLimiter(3, time.Second)

    var wg sync.WaitGroup

    // Simulate 10 operations
    for i := 1; i &lt;= 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()

            // Get the current time before waiting
            start := time.Now()

            // Wait for rate limiter
            limiter.Wait()

            // Calculate how long we waited
            waited := time.Since(start)

            fmt.Printf("Operation %d started at %s (waited %v)\n",
                      id, time.Now().Format("15:04:05.000"), waited)

            // Simulate work
            time.Sleep(100 * time.Millisecond)
        }(i)
    }

    wg.Wait()
    fmt.Println("All operations completed")
}
*/
</code></pre>
<h2 id="127-summary"><a class="header" href="#127-summary"><strong>12.7 Summary</strong></a></h2>
<p>In this chapter, we've explored Go's channels in depth:</p>
<ul>
<li>
<p><strong>Channel Fundamentals</strong>: We learned how channels work, including their creation, directionality, and operations like sending, receiving, and closing.</p>
</li>
<li>
<p><strong>Buffered vs. Unbuffered Channels</strong>: We examined the differences between buffered and unbuffered channels and when to use each type.</p>
</li>
<li>
<p><strong>Advanced Channel Operations</strong>: We covered essential operations like using the <code>select</code> statement, non-blocking operations, and implementing timeouts.</p>
</li>
<li>
<p><strong>Concurrency Patterns</strong>: We explored patterns like pipelines, worker pools, fan-out/fan-in, and rate limiting, which help solve common concurrency challenges.</p>
</li>
<li>
<p><strong>Advanced Patterns</strong>: We implemented more complex patterns including generators, futures/promises, and pub-sub systems.</p>
</li>
<li>
<p><strong>Best Practices</strong>: We discussed important principles like channel ownership, proper closing, buffer sizing, and error handling.</p>
</li>
</ul>
<p>Channels are a cornerstone of Go's concurrency model, embodying the language's philosophy: "Do not communicate by sharing memory; instead, share memory by communicating." By using channels effectively, you can build concurrent programs that are both efficient and maintainable.</p>
<p>Understanding channels and their patterns allows you to leverage Go's concurrency capabilities to their fullest potential, writing code that takes advantage of modern multi-core processors while maintaining readability and safety.</p>
<h2 id="128-next-steps"><a class="header" href="#128-next-steps"><strong>12.8 Next Steps</strong></a></h2>
<p>Now that you've mastered channels and goroutines (from Chapter 11), you have a solid foundation in Go's concurrency model. The next steps in your Go journey might include:</p>
<ol>
<li><strong>Exploring the standard library</strong> to see how it uses concurrency patterns</li>
<li><strong>Building real-world concurrent applications</strong> like web servers and data processing pipelines</li>
<li><strong>Learning advanced synchronization techniques</strong> with the <code>sync</code> and <code>sync/atomic</code> packages</li>
<li><strong>Investigating third-party concurrency libraries</strong> that build on Go's primitives</li>
</ol>
<p>In the next chapter, we'll explore Go's standard library and how it provides rich functionality for common programming tasks.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/Chapter-11-Goroutines.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapters/Chapter-13-Concurrency-Patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/Chapter-11-Goroutines.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapters/Chapter-13-Concurrency-Patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
